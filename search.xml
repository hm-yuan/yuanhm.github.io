<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>show me the money</title>
    <url>/2020/07/22/show-me-the-money/</url>
    <content><![CDATA[<p>show me the money</p>
]]></content>
  </entry>
  <entry>
    <title>[Advanced R] 4. 切片</title>
    <url>/2020/08/04/Advanced_R/Subsetting/</url>
    <content><![CDATA[<h2 id="Subsetting"><a href="#Subsetting" class="headerlink" title="Subsetting"></a>Subsetting</h2><blockquote>
<p>  <strong>切片（Subsetting）是str( )的延续步骤。</strong></p>
</blockquote>
<h3 id="R中的六种切片方式"><a href="#R中的六种切片方式" class="headerlink" title="R中的六种切片方式"></a>R中的六种切片方式</h3><ul>
<li><p>原子向量（atomic vector）中有六种切片方式，本质是通过逻辑值、序号、名字指定出特定元素。</p>
<pre><code class="hljs &#123;r&#125;">x &lt;- c(2, 1, 3, 4)
# positive integers——保留选择
x[order(x)]
#&gt; [1] 1 2 3 4
x[c(2.1, 2.2, 2.3, 2.6, 2.7, 2.8)] #R自动向下取整
#&gt; [1] 1 1 1 1 1 1

# negative integers——删去选择
x[-c(3, 1)]
#&gt; [1] 1 4

# logical vectors
x[c(T, T, F, T)]
#&gt; [1] 2 1 4
x[c(T, T, F)] #缺失的默认为TRUE
#&gt; [1] 2 1 4
x[c(T, F)] #长度不够自动循环
#&gt; [1] 2 3

# Nothing——返回原向量
x[]
#&gt; [1] 2 1 3 4

# zero——返回长度为0的向量
x[0]
#&gt; numeric(0)

# character vectors——如果原向量含有名字，那么通过选择名字来筛选</code></pre>
</li>
<li><p><strong>列表（list）</strong>的切片方式与原子向量相似，使用<strong>[ ]</strong>来返回list；使用<strong>[[ ]]</strong>和<strong>$</strong>来返回数值。</p>
</li>
<li><p>在处理多维结构的向量（如矩阵、数据框）时，可以选择三种方式来切片：</p>
<ul>
<li><p>多维向量：分别选定行、列</p>
</li>
<li><p>单一向量：由于多为结构本质上是向量，因而可以使用单一向量的方式来按顺序切片。</p>
<pre><code class="hljs &#123;r&#125;">vals &lt;- outer(1:5, 1:5, FUN &#x3D; &quot;paste&quot;, sep &#x3D; &quot;,&quot;)
vals
#&gt;      [,1]  [,2]  [,3]  [,4]  [,5] 
#&gt; [1,] &quot;1,1&quot; &quot;1,2&quot; &quot;1,3&quot; &quot;1,4&quot; &quot;1,5&quot;
#&gt; [2,] &quot;2,1&quot; &quot;2,2&quot; &quot;2,3&quot; &quot;2,4&quot; &quot;2,5&quot;
#&gt; [3,] &quot;3,1&quot; &quot;3,2&quot; &quot;3,3&quot; &quot;3,4&quot; &quot;3,5&quot;
#&gt; [4,] &quot;4,1&quot; &quot;4,2&quot; &quot;4,3&quot; &quot;4,4&quot; &quot;4,5&quot;
#&gt; [5,] &quot;5,1&quot; &quot;5,2&quot; &quot;5,3&quot; &quot;5,4&quot; &quot;5,5&quot;

vals[c(1, 4, 15)] #从第一列开始顺序筛选
[1] &quot;1,1&quot; &quot;4,1&quot; &quot;5,3&quot;</code></pre>
</li>
<li><p>矩阵（matrix）：使用<strong>2-column矩阵来筛选矩阵</strong>；使用<strong>3-column矩阵来筛选数组</strong>。</p>
<pre><code class="hljs &#123;r&#125;">select &lt;- matrix(ncol &#x3D; 2, byrow &#x3D; TRUE, c(
  1, 1,
  3, 1,
  2, 4
))
vals[select] #行、列分别用来指定特定位置
#&gt; [1] &quot;1,1&quot; &quot;3,1&quot; &quot;2,4&quot;</code></pre>
</li>
</ul>
</li>
<li><p><strong>Data.Frame</strong>同时具有list和matrix两方面特征</p>
<ul>
<li><p>输入单一参数时，<strong>Data.Frame</strong>表现得像lists，输入的参数<strong>对列进行切片</strong>。</p>
</li>
<li><p>输入两个参数时，<strong>Data.Frame</strong>表现得像matrices。但注意data.frame如下的细节，相对地，tibbles总是返回tibbles。<strong>这是因为在对data.frame或其它matrices进行切片时，R总是会返回降维后的值（除非使用drop = FALSE）</strong>。对此，tibbles默认了drop = FALSE。</p>
<pre><code class="hljs &#123;r&#125;">df &lt;- data.frame(x &#x3D; 1:3, y &#x3D; 3:1, z &#x3D; letters[1:3])
df[&quot;x&quot;]
#&gt;   x
#&gt; 1 1
#&gt; 2 2
#&gt; 3 3
df[,&quot;x&quot;]
#&gt; [1] 1 2 3</code></pre>
</li>
</ul>
</li>
<li><p><strong>因子向量（Factor）</strong>在进行切片时，如果不使用<strong>drop = FALSE</strong>，因子的level可能被遗弃。</p>
<pre><code class="hljs &#123;r&#125;">z &lt;- factor(c(&quot;a&quot;, &quot;b&quot;))
z[1]
#&gt; [1] a
#&gt; Levels: a b
z[1, drop &#x3D; TRUE]
#&gt; [1] a
#&gt; Levels: a</code></pre>
</li>
</ul>
<h3 id="选择特定变量"><a href="#选择特定变量" class="headerlink" title="选择特定变量"></a>选择特定变量</h3><p>使用<strong>[[ ]]</strong> 与 <strong>$</strong>来选择特定变量（$是[[ ]]的简写），效果相似，但存在如下区别：</p>
<ul>
<li><p><strong>$</strong>和<strong>[[</strong>在呼叫用另一个对象存储的变量时可能存在区别：x$y将被翻译为x[[“y”]]</p>
<pre><code class="hljs &#123;r&#125;">var &lt;- &quot;cyl&quot;
mtcars$var
#&gt; NULL
mtcars[[var]]
#&gt; [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4</code></pre>
</li>
<li><p><strong>$</strong>可以适用于部分匹配，而<strong>[[</strong>不行。</p>
</li>
</ul>
<h3 id="切片与赋值"><a href="#切片与赋值" class="headerlink" title="切片与赋值"></a>切片与赋值</h3><p><strong>x[i] &lt;- value</strong>是切片赋值的基本形式</p>
<ul>
<li><p>使用x[ ]空白切片来赋值具有一些特殊用法：</p>
<pre><code class="hljs &#123;r&#125;">mtcars &lt;- lapply(mtcars, as.integer) # 按column对对象使用函数
is.data.frame(mtcars)
#&gt; [1] TRUE

mtcars &lt;- lapply(mtcars, as.integer) # 相当于新赋予了一个变量
is.data.frame(mtcars)
#&gt; [1] FALSE</code></pre>
</li>
</ul>
<h3 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h3><h4 id="查询表格"><a href="#查询表格" class="headerlink" title="查询表格"></a>查询表格</h4><p>通过「字符串匹配」的方式，制作索引向量来替换变量：①字符串匹配；②<strong>[ ]</strong>查询是无限次的。</p>
<pre><code class="hljs &#123;r&#125;">x &lt;- c(&quot;m&quot;, &quot;f&quot;, &quot;u&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;, &quot;m&quot;)
lookup &lt;- c(m &#x3D; &quot;Male&quot;, f &#x3D; &quot;Female&quot;, u &#x3D; NA)
lookup
#&gt;        m        f        u 
#&gt;   &quot;Male&quot; &quot;Female&quot;       NA

lookup[x]
#&gt;        m        f        u        f        f        m        m 
#&gt;   &quot;Male&quot; &quot;Female&quot;       NA &quot;Female&quot; &quot;Female&quot;   &quot;Male&quot;   &quot;Male&quot;</code></pre>
<h4 id="通过匹配合并"><a href="#通过匹配合并" class="headerlink" title="通过匹配合并"></a>通过匹配合并</h4><p>制作信息表来方向匹配。</p>
<pre><code class="hljs &#123;r&#125;"># 数据
grades &lt;- c(1, 2, 2, 3, 2, 2, 1, 3, 1)

info_table &lt;- data.frame(
	grade &#x3D; 3:1,
    desc &#x3D; c(&quot;Excellent&quot;, &quot;Good&quot;, &quot;Poor&quot;),
    fail &#x3D; c(F, F, T)
)

# 匹配
id &lt;- match(grades, info_table$grade)
id 
#&gt; [1] 3 2 2 1 2 2 3 1 3
info_table[id,]
#&gt;   grade desc      fail 
#&gt;   &lt;int&gt; &lt;chr&gt;     &lt;lgl&gt;
#&gt; 1     1 Poor      TRUE 
#&gt; 2     2 Good      FALSE
#&gt; 3     2 Good      FALSE
#&gt; 4     3 Excellent FALSE
#&gt; 5     2 Good      FALSE
#&gt; 6     2 Good      FALSE
#&gt; 7     1 Poor      TRUE 
#&gt; 8     3 Excellent FALSE
#&gt; 9     1 Poor      TRUE</code></pre>
<h4 id="随机样本"><a href="#随机样本" class="headerlink" title="随机样本"></a>随机样本</h4><p>使用<strong>sample(n)</strong>来对矩阵、数据框随机切片（<strong>df[sample()]</strong>）。</p>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>使用<strong>c(1, 2, 3, …)</strong>，通过<strong>[[ ]]</strong>来对数据框重新排序。</p>
<h4 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h4><p>将选出的对象设置为NULL来移除特定变量，或者保留想要的。</p>
<pre><code class="hljs &#123;r&#125;">df &lt;- data.frame(x &#x3D; 1:3, y &#x3D; 3:1, z &#x3D; letters[1:3])
df[setdiff(names(df), &quot;z&quot;)]
#&gt;   x y
#&gt; 1 1 3
#&gt; 2 2 2
#&gt; 3 3 1</code></pre>
<h4 id="结合逻辑值"><a href="#结合逻辑值" class="headerlink" title="结合逻辑值"></a>结合逻辑值</h4><p>注意逻辑值和数值之间的转换，主要差别在于存在缺失值（<strong>NA</strong>）时：</p>
<ul>
<li><strong>c[which(x)]</strong>会在遇到NA时，直接遗弃对应值。</li>
<li><strong>c[x]</strong>会在遇到NA时，返回NA。</li>
</ul>
<pre><code class="hljs &#123;r&#125;">c &lt;- c(1:10)

# 设置切片条件
(x &lt;- sample(10) &lt; 4)
#&gt; [1] FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE
which(x) #将逻辑值转换为数值
#&gt; [1]  6  9 10

# 切片
(c[which(x)])
#&gt; [1] 3 6 9
(c[x])
#&gt; [1] 3 6 9</code></pre>
<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://adv-r.hadley.nz/" target="_blank" rel="noopener">《Advanced R》</a> 学习笔记。
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>[Advanced R] 3. 向量</title>
    <url>/2020/08/03/Advanced_R/Vectors/</url>
    <content><![CDATA[<h2 id="Vectors"><a href="#Vectors" class="headerlink" title="Vectors"></a>Vectors</h2><blockquote>
<p>  <strong>向量由</strong>原子向量（atomic vector）<strong>和</strong>列表（list）<strong>组成，二者的区别在于：原子向量中的每个元素具有相同的类别，而列表中元素的类别可以不同。</strong></p>
</blockquote>
<p><img src="https://d33wubrfki0l68.cloudfront.net/2ff3a6cebf1bb80abb2a814ae1cfc67b12817713/ae848/diagrams/vectors/summary-tree.png" srcset="/img/loading.gif" style="zoom:33%;" /></p>
<h3 id="原子向量"><a href="#原子向量" class="headerlink" title="原子向量"></a>原子向量</h3><p>原子向量（atomic vector）有四种基础类别：logical，integer，double，character。</p>
<p><img src="https://d33wubrfki0l68.cloudfront.net/eb6730b841e32292d9ff36b33a590e24b6221f43/57192/diagrams/vectors/summary-tree-atomic.png" srcset="/img/loading.gif" style="zoom:33%;" /></p>
<ul>
<li><p>绝大多数情况下与缺失值（NA）相关的表达式输出的都是NA。</p>
<pre><code class="hljs &#123;r&#125;">NA &gt; 5
#&gt; [1] NA
10 * NA
#&gt; [1] NA
!NA
#&gt; [1] NA

# 以下为特殊情况
NA ^ 0
#&gt; [1] 1
NA | TRUE
#&gt; [1] TRUE
NA &amp; FALSE
#&gt; [1] FALSE</code></pre>
</li>
<li><p>由于原子向量中的所有元素具有相同的属性，当试图合并两个不同类别的向量时，<strong>R</strong>会自动按照一个固定的顺序来强行调整类别（coerce）：<strong>character → double → integer → logical</strong>。对于logical向量，在使用数学函数时，其会自动转换为numeric。当强行调整类别失败时，<strong>R</strong>会返回NA。</p>
<pre><code class="hljs &#123;r&#125;">str(c(&quot;a&quot;, 1))
#&gt;  chr [1:2] &quot;a&quot; &quot;1&quot;

# 对于logical向量，在使用数学函数时，其会自动转换为numeric
x &lt;- c(FALSE, FALSE, TRUE)
as.numeric(x)
#&gt; [1] 0 0 1
sum(x)
#&gt; [1] 1

# 当强行调整类别失败时，R会返回NA
as.integer(c(&quot;1&quot;, &quot;1.5&quot;, &quot;a&quot;))
#&gt; Warning: NAs introduced by coercion
#&gt; [1]  1  1 NA</code></pre>
</li>
</ul>
<h3 id="属性（Attributes）"><a href="#属性（Attributes）" class="headerlink" title="属性（Attributes）"></a>属性（Attributes）</h3><p>属性（Attributes）能够使原子向量变为更多的其它类型。</p>
<ul>
<li><p>使用<strong>attr( )</strong>来获取和编辑单个属性，使用<strong>attributes( )</strong>来获取对象的所有属性信息。</p>
</li>
<li><p>属性（Attributes）只是暂时的，绝大多数基本的操作都会使对象丧失属性。</p>
<pre><code class="hljs &#123;r&#125;">a &lt;- 1:3
attr(a, &quot;x&quot;) &lt;- &quot;abc&quot;
attr(a, &quot;x&quot;)
#&gt; [1] &quot;abc&quot;

# 丧失属性
attributes(a[1])
#&gt; NULL</code></pre>
</li>
<li><p>名字（name）和维度（dim）是仅有的两个会提前预设的属性。</p>
<pre><code class="hljs &#123;r&#125;"># 三种命名方式
x &lt;- c(a &#x3D; 1, b &#x3D; 2, c &#x3D; 3)

x &lt;- 1:3
names(x) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)

x &lt;- setNames(1:3, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))
# 可使用unname(x)或names(x) &lt;- NULL 来去掉名称</code></pre>
<ul>
<li><p>增加维度（dim）使得向量升级为矩阵（matrix）或数组（array）。一般而言，适用于向量的函数，也有其在矩阵和数组中的形式</p>
<p>Vector|Matrix|Array<br> :—-: | :—-: | :—-: </p>
<pre><code> names()     | rownames(), colnames() |   dimnames()   
length()`     |     nrow(), ncol()     |     dim()      
   c()       |    rbind(), cbind()    | abind::abind() 
     —         |           t()            |    aperm()     
</code></pre><p> is.null(dim(x)) |       is.matrix()        |   is.array()   </p>
</li>
</ul>
</li>
</ul>
<h3 id="S3原子向量"><a href="#S3原子向量" class="headerlink" title="S3原子向量"></a>S3原子向量</h3><p>拥有<strong>class</strong>的向量即转换成了<strong>S3对象（S3 object）</strong>，有四种重要的S3对象：</p>
<ul>
<li><p>类别变量（category data）：<strong>factor</strong>是基于integer的S3对象，内含提前预设的值。</p>
<pre><code class="hljs &#123;r&#125;"># 基于integer的对象
x &lt;- factor(c(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;a&quot;))
typeof(x)
#&gt; [1] &quot;integer&quot;
class(x)
#&gt; [1] &quot;factor&quot;

attributes(x)
#&gt; $levels
#&gt; [1] &quot;a&quot; &quot;b&quot;

#&gt; $class
#&gt; [1] &quot;factor&quot;

# factor中规定的level数量可多余实际对象中的元素类别数量
x &lt;- factor(x, levels &#x3D; c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))
table(x)
#&gt; x
#&gt; a b c 
#&gt; 2 2 0</code></pre>
</li>
<li><p>日期（dates）：<strong>Date</strong>是基于double的S3对象，是距离1970-01-01的天数。</p>
<pre><code class="hljs &#123;r&#125;">typeof(Sys.Date())
#&gt; [1] &quot;double&quot;
class(Sys.Date())
#&gt; [1] &quot;Date&quot;
unclass(Sys.Date())
#&gt; [1] 18477</code></pre>
</li>
<li><p>时间（date-times）：<strong>POSIXct</strong>和<strong>POSIXlt</strong>是基于double构建的S3对象。</p>
<pre><code class="hljs &#123;r&#125;">now_ct &lt;- as.POSIXct(&quot;2018-08-01 22:00&quot;, tz &#x3D; &quot;UTC&quot;)
now_ct
#&gt; [1] &quot;2018-08-01 22:00:00 UTC&quot;

typeof(now_ct)
#&gt; [1] &quot;double&quot;
attributes(now_ct)
#&gt; $class
#&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot; 
#&gt; 
#&gt; $tzone
#&gt; [1] &quot;UTC&quot;</code></pre>
</li>
<li><p>区间（durations）：<strong>difftime</strong>是基于double构建的S3对象。</p>
<pre><code class="hljs &#123;r&#125;">one_week_1 &lt;- as.difftime(1, units &#x3D; &quot;weeks&quot;)
one_week_1
#&gt; Time difference of 1 weeks
typeof(one_week_1)
#&gt; [1] &quot;double&quot;
attributes(one_week_1)
#&gt; $class
#&gt; [1] &quot;difftime&quot;
#&gt; 
#&gt; $units
#&gt; [1] &quot;weeks&quot;</code></pre>
</li>
</ul>
<h3 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h3><p>使用<strong>list( )</strong>来生成列表，使用<strong>as.list( )</strong>来将对象转换为列表。</p>
<h3 id="Data-Frame-amp-Tibbles"><a href="#Data-Frame-amp-Tibbles" class="headerlink" title="Data Frame &amp; Tibbles"></a>Data Frame &amp; Tibbles</h3><p>Data Frame和Tibbles是构建在list基础上的两个重要S3对象。</p>
<ul>
<li><p>Data Frame和Tibbles的重要区别在于tibble从不强制修改其输入项。</p>
<ul>
<li><p>Data Frame会自动修改无效变量名，tibbles不会修改。</p>
</li>
<li><p>Data Frame和tibble都会自动循环填充较短的变量，但是tibble只有在变量为1的时候才会循环填充。</p>
</li>
<li><p>tibble在创建变量时即可引用</p>
<pre><code class="hljs &#123;r&#125;">tibble(
  x &#x3D; 1:3,
  y &#x3D; x * 2
)
#&gt; # A tibble: 3 x 2
#&gt;       x     y
#&gt;   &lt;int&gt; &lt;dbl&gt;
#&gt; 1     1     2
#&gt; 2     2     4
#&gt; 3     3     6</code></pre>
</li>
</ul>
</li>
<li><p>tibbles不支持rownames，相反，其提供<strong>rownames_to_column( )</strong>和<strong>rownames</strong>来将现有的行名称转换为变量。</p>
</li>
<li><p>只要确保行数相同，就可以添加matrix或array到原data.frame</p>
<pre><code class="hljs &#123;r&#125;">dfm &lt;- data.frame(x &#x3D; 1:3 * 10)
dfm$y &lt;- matrix(1:9, nrow &#x3D; 3) #矩阵变量
dfm$z &lt;- data.frame(a &#x3D; 3:1, b &#x3D; letters[1:3], stringsAsFactors &#x3D; FALSE) #data.frame变量

str(dfm)
#&gt; &#39;data.frame&#39;:	3 obs. of  3 variables:
#&gt;  $ x: num  10 20 30
#&gt;  $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9
#&gt;  $ z:&#39;data.frame&#39;:	3 obs. of  2 variables:
#&gt;   ..$ a: int  3 2 1
#&gt;   ..$ b: chr  &quot;a&quot; &quot;b&quot; &quot;c&quot;</code></pre>
<p><img src="https://d33wubrfki0l68.cloudfront.net/38c47352b8062a6d59318b3bbd1f86b062419322/7780c/diagrams/vectors/data-frame-matrix.png" srcset="/img/loading.gif" style="zoom:33%;" /></p>
</li>
</ul>
<h3 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h3><p><strong>NULL</strong>是特殊的类型，长度（length）为0，不能有任何属性（attributes）</p>
<pre><code><pre><code class="hljs &#123;r&#125;">typeof(NULL)
#&gt; [1] &quot;NULL&quot;

length(NULL)
#&gt; [1] 0

is.null(c())
#&gt; [1] TRUE</code></pre>
</code></pre><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://adv-r.hadley.nz/" target="_blank" rel="noopener">《Advanced R》</a> 学习笔记。
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>[Advanced R] 2. 名称与对象</title>
    <url>/2020/08/02/Advanced_R/Names_and_Values/</url>
    <content><![CDATA[<h2 id="Names-and-Values"><a href="#Names-and-Values" class="headerlink" title="Names and Values"></a>Names and Values</h2><blockquote>
<p>  <strong>对象（object）并没有名字（name），只是名字有了对象」</strong></p>
</blockquote>
<h3 id="名字与对象的链接"><a href="#名字与对象的链接" class="headerlink" title="名字与对象的链接"></a>名字与对象的链接</h3><p>名字和对象是独立的，二者通过<strong>“ &lt;- ”</strong>相连。</p>
<ul>
<li>每个对象在R中都有自己的编号（如下的 “0x1deba3bd8f8”）。</li>
<li>名字与对象直接相连，名字只是对象的<strong>查询编码（Reference）</strong>：<img src="https://d33wubrfki0l68.cloudfront.net/bdc72c04d3135f19fb3ab13731129eb84c9170af/f0ab9/diagrams/name-value/binding-2.png" srcset="/img/loading.gif" style="zoom: 33%;" /></li>
</ul>
<pre><code class="hljs &#123;r&#125;"># 变量与对象的关系
x &lt;- c(1, 2, 3)
y &lt;- x

# x, y实际指向了同一个对象
lobstr::obj_addr(x)
# [1] &quot;0x1deba3bd8f8&quot;
lobstr::obj_addr(y)
# [1] &quot;0x1deba3bd8f8&quot;</code></pre>
<h3 id="Copy-on-modify"><a href="#Copy-on-modify" class="headerlink" title="Copy-on-modify"></a>Copy-on-modify</h3><ol>
<li><p><strong>Basic：</strong>对象是不可修改的，<strong>只能对复制的对象进行修改（Copy-on-modify）</strong></p>
<ul>
<li><p>修改y并不会改变x的值，只是通过复制对象，并在复本的基础上新生成了一个对象：<img src="https://d33wubrfki0l68.cloudfront.net/ef9f480effa2f1d0e401d1f94218d0cf118433c0/b56e9/diagrams/name-value/binding-3.png" srcset="/img/loading.gif" style="zoom:33%;" /></p>
<pre><code class="hljs &#123;r&#125;"># 追踪x对象：如果复制发生，则将通知
tracemem(x)
#&gt; [1] &quot;&lt;000001DEBA3BD8F8&gt;&quot;
y[[3]] &lt;- 4L
#&gt; tracemem[0x000001deba3bd8f8 -&gt; 0x000001deba3b0d58]:

# 修改y并不会改变x的值
x
#&gt; [1] 1 2 3
y
#&gt; [1] 1 2 4

# 修改y实际上新生成了一个变量
lobstr::obj_addr(y)
#&gt; [1] &quot;0x1deba3b0d58&quot;</code></pre>
</li>
</ul>
</li>
<li><p><strong>Function：</strong>函数（Function）中的对象同样使用<strong>Copy-on-modify</strong>准则</p>
<ul>
<li><p>函数的运行结果相当于建立了新的链接，其中没有涉及复制：<img src="https://d33wubrfki0l68.cloudfront.net/e8718027aabaed377da311f45b45a179588e4dcf/6bf90/diagrams/name-value/binding-f2.png" srcset="/img/loading.gif" style="zoom:33%;" /></p>
<pre><code class="hljs &#123;r&#125;">f &lt;- function(a) a
x &lt;- c(1, 2, 3)
tracemem(x)
z &lt;- f(x)
# 没有复制发生！</code></pre>
</li>
</ul>
</li>
<li><p><strong>List：</strong>列表（list）指向的不是值（value），而是查询编码（Reference）的集合</p>
<ul>
<li><p>当修改发生时，只是修改部分查询编码的指向：<img src="https://d33wubrfki0l68.cloudfront.net/b844bb5a3443e1344299627f5760e2ae3a9885b5/e1c76/diagrams/name-value/l-modify-2.png" srcset="/img/loading.gif" style="zoom: 33%;" /></p>
<pre><code class="hljs &#123;r&#125;">l1 &lt;- c(1, 2, 3)
l2 &lt;- l1
l2[[3]] &lt;- 4L
lobstr:ref(l1, l2)
#&gt; o [1:0x1deb8aecdf0] &lt;list&gt; 
#&gt; +-[2:0x1deba502740] &lt;dbl&gt; 
#&gt; +-[3:0x1deba502778] &lt;dbl&gt; 
#&gt; \-[4:0x1deba5027b0] &lt;dbl&gt; 
 
#&gt; o [5:0x1deba41de78] &lt;list&gt; 
#&gt; +-[2:0x1deba502740] 
#&gt; +-[3:0x1deba502778] 
#&gt; \-[6:0x1deba5f0fd0] &lt;int&gt;</code></pre>
</li>
</ul>
</li>
<li><p><strong>Date Frame：</strong>数据框（Data frames）是向量的列表（list of vectors），适用相同的规制</p>
<ul>
<li>修改列时：仅有<strong>被修改的列指向的对象</strong>会发生改变。</li>
<li>修改行时：<strong>所有列指向的对象</strong>都发生了改变。</li>
</ul>
</li>
<li><p><strong>Character vectors：</strong>字符串向量（Character vectors）指向的是在全局中包含多种字符串的池。当修改发生时，是部分字符串的查询编码发生了改变，因而总体的对象也不同了</p>
<pre><code class="hljs &#123;r&#125;">x &lt;- c(&quot;a&quot;, &quot;a&quot;, &quot;abc&quot;, &quot;d&quot;)
y &lt;- x
y[[1]] &lt;- &quot;c&quot;
# 指向的对象不同了
ref(x, y)
#&gt; [1:0x1deb8b09248] &lt;chr&gt; 

#&gt; [2:0x1deb8ab1b10] &lt;chr&gt; 

# 实际是具体修改的字符串查询编码变化了
ref(x, y, character &#x3D; T)
#&gt; o [1:0x1deb8b09248] &lt;chr&gt; 
#&gt; +-[2:0x1deb133d720] &lt;string: &quot;a&quot;&gt; 
#&gt; +-[2:0x1deb133d720] 
#&gt; +-[3:0x1deb550c728] &lt;string: &quot;abc&quot;&gt; 
#&gt; \-[4:0x1deb150d048] &lt;string: &quot;d&quot;&gt; 
 
#&gt; o [5:0x1deb8ab1b10] &lt;chr&gt; 
#&gt; +-[6:0x1deb00e29f0] &lt;string: &quot;c&quot;&gt; 
#&gt; +-[2:0x1deb133d720] 
#&gt; +-[3:0x1deb550c728] 
#&gt; \-[4:0x1deb150d048]</code></pre>
</li>
</ol>
<h3 id="对象的大小（Object-size）"><a href="#对象的大小（Object-size）" class="headerlink" title="对象的大小（Object size）"></a>对象的大小（Object size）</h3><ol>
<li><p>由于列表（list）实质上是储存了对象的查询编码，所以列表的大小可能远小于预期。</p>
<pre><code class="hljs &#123;r&#125;">x &lt;- runif(1e6)
lobstr::obj_size(x)
#&gt; 8,000,048 B
y &lt;- list(x, x, x)
lobstr::obj_size(y)
#&gt; 8,000,128 B</code></pre>
</li>
<li><p>由于R中的字符串同样采用类似于list的字符串池（string pool）的方式，所以重复字符串后的大小也小于预期。</p>
<pre><code class="hljs &#123;r&#125;">banana &lt;- &quot;bananas bananas bananas&quot;
obj_size(banana)
#&gt; 136 B
obj_size(rep(banana, 100))
#&gt; 928 B</code></pre>
</li>
<li><p>变量相加后的大小类似于<strong>并集</strong>的关系，如果二者没有相同的值，那么对象相加后的大小就等于两个单独的大小相加。</p>
</li>
</ol>
<h3 id="立即修改"><a href="#立即修改" class="headerlink" title="立即修改"></a>立即修改</h3><p>并非所有对对象的修改都是<strong>copy-on-modify</strong>，有两类例外，他们是<strong>将对象本身立即修改的（modify-in-place）</strong>：</p>
<ol>
<li><p>仅有单一链接（binding）的对象</p>
<p>单一链接（binding）的对象会直接对自身进行修改。但每次使用常规函数时，都会将对象的链接增加，并且不能再回到1。</p>
<p>事实上，R中循环（loops）的缓慢正是因为其不断地在复制对象。<strong>此时可以考虑将data.frame转换为list来进入循环，因为list允许单独修改某一查询编码（Reference）。</strong></p>
<pre><code class="hljs &#123;r&#125;">x &lt;- data.frame(matrix(runif(5 * 1e4), ncol &#x3D; 5))
medians &lt;- sapply(x, median, numeric(i))
tracemem(x)
#&gt; [1] &quot;&lt;000001402BEBE6B0&gt;&quot;

# 直接使用循环，对象在每次迭代中被复制了两次
for (i in seq_along(medians)) x[[i]] &lt;- x[[i]] - medians[[i]]
#&gt; tracemem[0x000001402bebe6b0 -&gt; 0x0000014029bcf0b0]: 
#&gt; tracemem[0x0000014029bcf0b0 -&gt; 0x0000014029bcf190]: [[&lt;-.data.frame [[&lt;- 
#&gt; tracemem[0x0000014029bcf190 -&gt; 0x0000014029bcf580]: 
#&gt; tracemem[0x0000014029bcf580 -&gt; 0x0000014029bcf6d0]: [[&lt;-.data.frame [[&lt;- 
#&gt; tracemem[0x0000014029bcf6d0 -&gt; 0x0000014029b9d750]: 
#&gt; tracemem[0x0000014029b9d750 -&gt; 0x0000014029b9d9f0]: [[&lt;-.data.frame [[&lt;- 
#&gt; tracemem[0x0000014029b9d9f0 -&gt; 0x0000014029b9dfa0]: 
#&gt; tracemem[0x0000014029b9dfa0 -&gt; 0x0000014029b9e160]: [[&lt;-.data.frame [[&lt;- 
#&gt; tracemem[0x0000014029b9e160 -&gt; 0x0000014029b9e550]: 
#&gt; tracemem[0x0000014029b9e550 -&gt; 0x0000014029b9ea90]: [[&lt;-.data.frame [[&lt;- 

# 将data.frame转换为list，仅有一次复制发生
y &lt;- as.list(x)
#&gt; tracemem[0x0000014029b9ea90 -&gt; 0x000001402f1245e0]: as.list.data.frame as.list 
for (i in seq_along(medians)) y[[i]] &lt;- y[[i]] - medians[[i]]
#&gt; tracemem[0x000001402f1245e0 -&gt; 0x000001402f47f7c0]:</code></pre>
</li>
</ol>
<ol>
<li><p>环境（environment）</p>
<p>环境（environment）是一种特殊的对象，实质是多个对象和名称链接的集合，它总是立即修改的（modify-in-place）。</p>
<pre><code class="hljs &#123;r&#125;">e1 &lt;- rlang::env(a &#x3D; 1, b &#x3D; 2, c &#x3D; 3)
e2 &lt;- e1

# 修改e1中的对象后，e2同步改变了
e1$c &lt;- 4
e2$c
#&gt; [1] 4</code></pre>
</li>
</ol>
<h3 id="清理内存"><a href="#清理内存" class="headerlink" title="清理内存"></a>清理内存</h3><p>使用<strong>rm( )</strong>只能删去名称与对象的链接，并不能删去对象。</p>
<ul>
<li>使用<strong>gc( )</strong>来清理内存，<strong>gcinfo( TRUE )</strong>来显示每次计算机清理内存的操作。</li>
<li>使用<strong>men_used( )</strong>来查看已消耗的内存。</li>
</ul>
<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://adv-r.hadley.nz/" target="_blank" rel="noopener">《Advanced R》</a>学习笔记。
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>[CFA-1] 投资组合</title>
    <url>/2020/02/29/CFA/Portfolio_Management/</url>
    <content><![CDATA[<h2 id="Portfolio-Management"><a href="#Portfolio-Management" class="headerlink" title="Portfolio Management"></a>Portfolio Management</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><strong>「投资组合的好处：一定条件下，多元化有助于降低整体风险」</strong></p>
<h5 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h5><ul>
<li><p>组合视角（portfolio perspective）</p>
<p>  组合视角：通过一只股票对整个组合<strong>收益</strong>、<strong>风险</strong>的影响来对其评估。</p>
</li>
<li><p>多元化的价值（risk-reduction benefits of diversification）</p>
<p> <strong>在资产不是绝对正相关的情况下</strong>，多元化有助于降低资产组合的风险。<strong>随着相关性增加</strong>，多元化带来的收益将下降。</p>
<blockquote>
<p>  多元化比率（diversification ratio）：$R_{p}/R_i$</p>
<ul>
<li>度量多元化带来的风险减少收益。</li>
</ul>
</blockquote>
</li>
<li><p>组合管理步骤（portfolio management process）</p>
<ol>
<li>计划阶段：设定各类参数<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="预期收益水平、风险承受能力、时间偏好、税率、流动性
">[1]</span></a></sup>。形成<strong>investment policy statement (IPS)</strong>，包含盈利目标和条件。</li>
<li>执行阶段：通过分析，决定资产组合方案。</li>
<li>反馈阶段：评估风险、收益，并作出调整。</li>
</ol>
</li>
</ul>
<h5 id="投资者、基金类型"><a href="#投资者、基金类型" class="headerlink" title="投资者、基金类型"></a>投资者、基金类型</h5><ul>
<li><p>固定缴存计划（defined contribution）、固定收益计划（defined benefit pension）</p>
<ul>
<li>固定缴存承诺过程，固定收益承诺回报。</li>
</ul>
</li>
<li><p>资产管理行业</p>
<ul>
<li>passive management：较低管理费用，较低风险，较低但相对稳定的收益</li>
<li>active management</li>
</ul>
</li>
<li><p>:question:几种类型的混合基金 </p>
<ul>
<li><p>共同基金</p>
<ul>
<li><p>可分为：开放式和封闭式</p>
<ul>
<li>open-end：可赎回、可交易</li>
</ul>
<blockquote>
<p>  投资者数量、基金池总额变动。</p>
</blockquote>
</li>
<li><p>closed-end：不可赎回、可交易</p>
<blockquote>
<p>  大多为主动管理</p>
<p>  直接与市场进行基金交易</p>
</blockquote>
</li>
</ul>
</li>
<li><p>其它几种类型</p>
<pre><code>-   货币基金：购买货币
</code></pre><ul>
<li>债券基金<ul>
<li>股票基金</li>
</ul>
</li>
</ul>
</li>
<li><p>exchange-traded fund（ETF）</p>
<ul>
<li><p>与closed-end基金比较：</p>
<p>相似：可交易、不可赎回</p>
<p>不同：大多为采用消极管理，紧跟指数收益。</p>
</li>
<li><p>与open-end基金比较：</p>
<p>不同：经纪人佣金（brokerage cost）较高；open-end能够以资产净值（NAV）进行买卖，而ETF买卖价格由</p>
</li>
</ul>
</li>
<li><p>私募、风险投资、套利基金（hedge funds）</p>
</li>
</ul>
</li>
</ul>
<h3 id="Portfolio-Risk-and-Return-Ⅰ"><a href="#Portfolio-Risk-and-Return-Ⅰ" class="headerlink" title="Portfolio Risk and Return Ⅰ"></a>Portfolio Risk and Return Ⅰ</h3><p><strong>「选取最优的投资组合：风险、收益以及投资者偏好」</strong></p>
<h5 id="收益计算"><a href="#收益计算" class="headerlink" title="收益计算"></a>收益计算</h5><ul>
<li><p>持有期收益(Holding period return)</p>
<blockquote>
<p>  $HPR = P_t-P_0+Div_t/P_0$</p>
</blockquote>
</li>
<li><p>平均收益</p>
<ul>
<li>算术平均：</li>
<li>几何平均：当各期收益率不同实，几何平均＜算术平均</li>
</ul>
</li>
<li><p>真实收益：<strong>近似</strong>等于名义收益—通货膨胀率</p>
</li>
<li><p>货币加权收益（money-weighted return）：考虑所有资金流入、流出的收益</p>
<ul>
<li><p>$PV<em>{inflow} = PV</em>{outflow}$</p>
</li>
<li><p>由于越往后账户中的货币越多，所以越往后期间内的权重可能变大。</p>
<blockquote>
<p>  如果追加投入后，收益下降，那么货币加权收益也将偏低。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>时间加权收益（time-weighted return）</p>
<ul>
<li>单独计算每期收益，最终求各期算术平均。</li>
</ul>
</li>
</ul>
<h5 id="协方差和相关性"><a href="#协方差和相关性" class="headerlink" title="协方差和相关性"></a>协方差和相关性</h5><ul>
<li><p>协方差：</p>
<ul>
<li>协方差的量级取决于：①单个对象收益标准差大小；②两个对象收益的同步变化程度</li>
<li>使用算术平均计算单个对象的平均收益</li>
</ul>
</li>
<li><p>相关性：对协方差剔除单个因子的影响（标准化后的协方差）</p>
<p>$ρ_{1,2}=COV/δ_1δ_2$</p>
<ul>
<li>相关性系数值域在【0，1】</li>
</ul>
</li>
</ul>
<h5 id="效率前沿-star"><a href="#效率前沿-star" class="headerlink" title="效率前沿:star:"></a>效率前沿:star:</h5><ul>
<li><p>组合方差、标准差的计算</p>
<p>$Var_{portfolio}=w_1^2σ_1^2+w_2^2σ_2^2+2w_1w_2Cov_12$</p>
<p>$σ<em>{portfolio}=Var</em>{portfolio}^{0.5}$</p>
<blockquote>
<p>  当两个对象呈正相关时，投资组合风险才等于各个资产的加权平均：</p>
<p>  $σ_{portfolio}=w_1σ_1+w_2σ_2$</p>
</blockquote>
<ul>
<li><p>相关系数越小时，组合方差越小。（多元化的优势）</p>
<p>-1 &gt; 0 &gt; 1</p>
</li>
</ul>
</li>
<li><p>效率前沿概念</p>
<ul>
<li><p>最小方差效率前沿：<strong>给定收益</strong>的所有可能的最小方差组合（minimum-variance portfolios）构成最小方差的效率前沿。</p>
</li>
<li><p>效率前沿：<strong>给定风险水平</strong>的收益最高的投资组合的集合</p>
<blockquote>
<p>  风险厌恶者只会选择位于效率前沿上的投资组合。</p>
</blockquote>
</li>
<li><p>全局最小方差组合：效率前沿上风险最低的投资组合</p>
</li>
</ul>
</li>
<li><p>资本分配曲线</p>
<ul>
<li>two-fund separation theorem：最优的投资者组合应<strong>优化的风险资产</strong>与<strong>无风险资产</strong>的组合</li>
</ul>
</li>
</ul>
<pre><code>-   资本分配线（capital allocation line，**CAL**）

    一条带有截距项的直线：

    $R=R_F+W_AR_A$

    &gt;   **资产分配线**与投资者**无差异曲线**的**切点**即为最优投资组合

-   与风险偏好相结合：

    一个风险厌恶程度更低的人，将获得更高收益，但更高风险的最优投资组合。
</code></pre><h3 id="Portfolio-Risk-and-Return-Ⅱ"><a href="#Portfolio-Risk-and-Return-Ⅱ" class="headerlink" title="Portfolio Risk and Return Ⅱ"></a>Portfolio Risk and Return Ⅱ</h3><p><strong>「风险与收益并不总是成正比：承担额外的非系统性风险并不会增加收益」</strong></p>
<h5 id="系统性风险"><a href="#系统性风险" class="headerlink" title="系统性风险"></a>系统性风险</h5><ul>
<li><p>将无风险资产加入投资组合：</p>
<p>$σ_{portfolio}=W_Aσ_A$</p>
<p>$E(R_p)=W_AE(R_A)+W_BE(R_B)$</p>
</li>
<li><p>能增加收益的风险</p>
<ol>
<li><p><strong>确定最优的无风险资产和有风险资产比例</strong></p>
<p>最优的CAL：与投资者无差别曲线相切的CAL</p>
</li>
<li><p><strong>确定CML和最优风险资产组合</strong></p>
<p>最优风险资产组合：最优CAL与效率前沿的切点</p>
<blockquote>
<p>  :star: 确定最优的市场回报点（$E(R_M)$），以此为依据判断具体资产是否值得买入：</p>
<ul>
<li><p>某项资产收益＞$E(R_M)$：买入</p>
</li>
<li><p>某项资产收益＜$E(R_M)$：卖出</p>
</li>
</ul>
</blockquote>
</li>
</ol>
<p>$E(R_p)=R_f+(E(R_M)-R_f)(σ_P/σ_M)$</p>
<ul>
<li>关于$σ_P$的函数</li>
<li><p>市场风险回报（market risk premium）：$E(R_M)-R_f$</p>
<blockquote>
<p>  :star: 为额外承受的每一单位市场风险（$σ_M$）获取市场风险回报</p>
<p>  承担额外的非系统性风险并不会增加收益</p>
</blockquote>
</li>
</ul>
</li>
<li><p>系统系风险：不能被多元化所抵消的风险（risk of well-diversified portfolio）</p>
<ul>
<li><p>系统性风险是相对的：由组合的具体情况决定。</p>
<blockquote>
<p>  一般弹性较大的资产组合具有较高的系统性风险。例如奢侈品具有较高的系统系风险。</p>
</blockquote>
</li>
<li><p>高风险股票不意味着高<strong>预期收益</strong>：只有背负系统性风险才能获取更高的<strong>预期收益</strong>（equilibrium return）。</p>
</li>
</ul>
</li>
</ul>
<h5 id="β"><a href="#β" class="headerlink" title="β"></a>β</h5><ul>
<li><p>计算单个资产的超额收益：超额收益是单个资产对多种因素敏感性的</p>
<ol>
<li><p>FAMA多因子模型：超额收益 = 敏感性1×因素1+敏感性2×因素2</p>
</li>
<li><p>单因子模型：资产的超额收益是β与市场超额收益的乘积</p>
<p>$E(R_i)-R_f=β_i×[E(R_m)-R_f]$</p>
</li>
<li><p>市场模型（market model）：</p>
<p>$R_i=α_i+β_iR_m+e_i$</p>
<ul>
<li><p>截距项$α_i=(1-β_i)$</p>
</li>
<li><p>预期收益$E(R_i)=α_i+β_iR_m$</p>
</li>
</ul>
<blockquote>
<p>  <strong>β表示一项资产对市场组合（market portfolio）的敏感性程度。</strong></p>
</blockquote>
</li>
</ol>
</li>
<li><p>BETA（β）的计算</p>
<p>:star: β是特殊标准化处理后的资产回报与市场回报的协方差: </p>
<ol>
<li>基本表达式：$β<em>i=COV</em>{im}/σ_M^2$</li>
<li>用相关系数代表协方差：$β<em>i=ρ</em>{im}(σ_i/σ_M)$</li>
</ol>
</li>
</ul>
<h5 id="CAPM模型"><a href="#CAPM模型" class="headerlink" title="CAPM模型"></a>CAPM模型</h5><ul>
<li><p>模型：描述预期资产回报与系统性风险的关系</p>
<p>$E(R<em>i)=R_f+β_i[E(R</em>{mkt}-R_f)]$</p>
<blockquote>
<p>  <strong>关于β的另一种理解：β是标准化后的系统性风险</strong></p>
<ul>
<li><p>$β=COV<em>{i,mkt}/σ</em>{mkt}^2$</p>
<p>:star:<strong>贝塔系数越高，投资该股的系统风险越高，投资者所要求的回报率也就越高</strong></p>
</li>
</ul>
</blockquote>
</li>
<li><p>内涵：资产的预期收益率等于无风险收益率加上β调整后的市场风险回报（market risk premium，$E(R_M)-R_f$）</p>
<ul>
<li>当β＞1时，资产收益大于市场收益</li>
<li>前提假设：①市场厌恶；②效用最大化；③无摩擦市场；④单期决定；⑤同质性假设；⑥所有资产可以随意拆分；⑦完全竞争市场</li>
</ul>
</li>
<li><p>CML与SML的区别:question:</p>
<ul>
<li><p>CML（capital market line）考虑了所有风险因素（total risk），所有CML上的点都是各自风险水平下最有效的（<strong>well-diversified</strong>）投资组合</p>
<blockquote>
<p>  <strong>没有完全多元化的</strong>的出现在与CML相切的效率前沿内。</p>
<p>  CML曲线上比切点高还是低来判断买入无风险资产来投资，或是投资无风险资产</p>
</blockquote>
</li>
<li><p>SML（security market line）考虑系统性风险（systematic risk），只要是定价合理的投资组合都在SML上</p>
<blockquote>
<p>  所有没在SML上的点都是在相同市场风险水平下，被错误定价的：</p>
<p>  SML下方：定价过高，卖出</p>
<p>  SML上方：定价过低，买入</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="几种重要的比率"><a href="#几种重要的比率" class="headerlink" title="几种重要的比率"></a>几种重要的比率</h5><ul>
<li><p>Sharp ratio：风险调整的收益</p>
<p>Sharp ratio = $E(R<em>{portfolio}-R_f)/σ</em>{portfolio}$</p>
<ul>
<li>是CAL的斜率</li>
<li>sharp ratio 越高，表现越好</li>
<li>基于总风险，而非系统风险：适用于各类投资类型分析。</li>
</ul>
</li>
<li><p>treynor ratio</p>
</li>
</ul>
<ul>
<li><p>$M^2$：承担每一份系统性风险的收益</p>
<p>$M^2 = R_p-R_f/β_p$</p>
</li>
<li><p>Jensen‘s alpha</p>
</li>
</ul>
<h3 id="Basic-of-Portfolio-Planning-and-Construction"><a href="#Basic-of-Portfolio-Planning-and-Construction" class="headerlink" title="Basic of Portfolio Planning and Construction"></a>Basic of Portfolio Planning and Construction</h3><h5 id="投资政策说明书（investment-policy-statement）"><a href="#投资政策说明书（investment-policy-statement）" class="headerlink" title="投资政策说明书（investment policy statement）"></a>投资政策说明书（investment policy statement）</h5><ul>
<li><p>组成要素：</p>
<ul>
<li><p>投资者环境（circumstance）：风险承受水平、预期收益</p>
<blockquote>
<p>  objectives and constraints</p>
</blockquote>
</li>
<li><p>投资策略（investment strategy）</p>
</li>
<li><p>对标（benchmark）：评估绩效</p>
</li>
</ul>
</li>
<li><p>投资者方面</p>
<ul>
<li>投资与风险目标（objectives）<ul>
<li>绝对风险目标与相对风险目标：对标benchmark设置收益不足预期的范围</li>
</ul>
</li>
<li>投资局限性（constraints）<ul>
<li>流动性要求</li>
<li>时间期限</li>
<li>税务</li>
<li>合规性</li>
</ul>
</li>
</ul>
</li>
<li><p>资产投资策略（strategic asset allocation）</p>
<ol>
<li><p>分清不同资产的收益与风险级别</p>
<blockquote>
<p>  包含：</p>
<p>  growth assets：指数、股票等</p>
<p>  downturn hedging assets：短期高质量信用贷款、固定收益（core）</p>
<p>  inflation hedging assets：房地产（core）、基础设施、抗通胀债券</p>
</blockquote>
</li>
<li><p>将投资策略与IPS相结合：选取最优投资组合</p>
<ul>
<li>主要根据objective（预期风险和收益目标）来选择</li>
<li>主动投资管理：可能带来更高风险与收益<ul>
<li>为获取短期收益进行技术性调整：tactical asset allocation</li>
<li>risk budgeting：①设定总风险水平；②设定技术性操作的风险额度。<ul>
<li>多个不同主动投资管理的风险可以对冲</li>
<li>多个主动投资管理可能带来更高的税务问题</li>
</ul>
</li>
<li>核卫星策略（core-statellite approach）：将核心资产（大部分资产）投资于被动管理的指数基金</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="Introduction-to-Risk-Management"><a href="#Introduction-to-Risk-Management" class="headerlink" title="Introduction to Risk Management"></a>Introduction to Risk Management</h3><h5 id="关于风险管理"><a href="#关于风险管理" class="headerlink" title="关于风险管理"></a>关于风险管理</h5><ul>
<li><p>目的：风险管理的目的并非要最小化风险，而是<strong>在一定的风险水平下获取最大的收益</strong>。</p>
</li>
<li><p>风险管控（risk governance）：明确各项风险管理政策。</p>
</li>
<li><p>风险承受水平（risk tolerance）：关于确定总风险水平，由企业的能力及环境决定。</p>
</li>
<li><p>风险预算（risk budgeting）：关于向各资产分配风险配额。</p>
<blockquote>
<p>  重点在于结合具体股票的风险特点和总的风险水平，来<strong>选择</strong>资产组合，从而通过风险对冲等方式找到最佳组合，</p>
</blockquote>
</li>
</ul>
<h5 id="关于风险"><a href="#关于风险" class="headerlink" title="关于风险"></a>关于风险</h5><ul>
<li>财务风险：来源于金融市场的风险<ul>
<li>信用风险：企业无法按时履约</li>
<li>流动性风险：需要以低于真实价格来出售资产</li>
<li>市场风险：利率及资本定价的调整</li>
</ul>
</li>
<li><p>非财务风险</p>
<ul>
<li>经营风险</li>
<li>偿债风险</li>
<li>政策风险</li>
<li>合规性风险</li>
<li>会计风险</li>
<li>模型风险：分析模型错误</li>
<li>尾部风险：低估小概率时间的爆发</li>
</ul>
</li>
<li><p>风险度量方式</p>
<ul>
<li><p>标准差：度量资产定价及收益（price &amp; interest rates）</p>
<ul>
<li>适用于独立的（stand-alone）资产</li>
</ul>
</li>
<li><p>β：度量收益对市场风险（不稳定性/变化）的敏感性</p>
<ul>
<li>β的本质是资产收益与市场收益的协方差，现实中可以用个股对指数间的关系来计算。</li>
</ul>
</li>
<li><p>久期：度量债券价格对利率变化的敏感性</p>
<ul>
<li><p>度量债券的利率风险</p>
<blockquote>
<p>  久期越短，债券价格的波动越小，风险越小；</p>
<p>  久期越长，债券价格的波动越大，风险越大。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Var：风险资产</p>
<ul>
<li>CVar：在最小损失已经确实后，预期的损失</li>
<li>压力测试：设定关键变量，评估后果</li>
<li>情景分析：改变多个输入变量，评估后果</li>
</ul>
</li>
</ul>
</li>
<li><p>风险应对策略</p>
<ul>
<li>avoid：不参与</li>
<li>prevent：补充监管，弥补数据漏洞</li>
<li>management：多元化<ul>
<li>risk transfer：保险、担保（surety bond）</li>
<li>risk shifting：改变风险的结果（风险发生了，但结果不一样）。<strong>一般选择衍生品。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="技术性分析"><a href="#技术性分析" class="headerlink" title="技术性分析"></a>技术性分析</h3><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><ul>
<li>概念：结合市场情绪对买卖双方的行为进行预测<ul>
<li>考虑市场理性和非理性因素，<strong>认为投资者的行为模式是可预测的</strong>（不基于市场有效性假说）</li>
<li>与基本面分析的区别<ul>
<li>基本面分析重在发现资产内在价值，技术性分析在于分析交易发生逻辑</li>
<li>基本面分析依据公司财报等多方面信息，技术性分析只考虑股价及交易量。</li>
<li>技术性分析不关注买卖双方的原因，仅关注已发生的交易。</li>
</ul>
</li>
<li>技术分析的优缺点<ul>
<li>优点：①基于客观且可观测数据；②可用于对未来不产生现金流的资产的定价，如原油。</li>
<li>缺点：不能反映资产真正的供需关系</li>
</ul>
</li>
</ul>
</li>
<li>常见类型<ul>
<li>反转形态（reversal patterns）</li>
</ul>
</li>
</ul>
<h3 id="Fintech-in-Investment-Management"><a href="#Fintech-in-Investment-Management" class="headerlink" title="Fintech in Investment Management"></a>Fintech in Investment Management</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>预期收益水平、风险承受能力、时间偏好、税率、流动性
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>CFA</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>[CFA-1] 权益投资</title>
    <url>/2020/02/29/CFA/Equity_Investment/</url>
    <content><![CDATA[<h2 id="Equity-Investment"><a href="#Equity-Investment" class="headerlink" title="Equity Investment"></a>Equity Investment</h2><h3 id="Market-Organization-and-Structure"><a href="#Market-Organization-and-Structure" class="headerlink" title="Market Organization and Structure"></a>Market Organization and Structure</h3><h5 id="金融市场基本概念"><a href="#金融市场基本概念" class="headerlink" title="金融市场基本概念"></a>金融市场基本概念</h5><ul>
<li>金融市场的作用<ul>
<li>通过利率决定资金供给</li>
<li>有效配置资源</li>
</ul>
</li>
<li>金融资产<ul>
<li>证券</li>
<li>衍生品</li>
<li>外汇</li>
</ul>
</li>
<li><p>市场</p>
<ul>
<li>现货市场（spot market）- 期货市场</li>
<li>一级市场：IPO等新发证券 - 二级市场：股票市场</li>
<li>货币市场：短期债券交易 - 资本市场：长期债券交易</li>
<li>传统市场：债权与股权交易 - 替代市场：对冲基金、大众商品、房地产交易</li>
</ul>
</li>
<li><p>证券（securities）</p>
<ul>
<li><p>固定收益：债券（debt security）</p>
</li>
<li><p>浮动收益：股票（equity security）</p>
<ul>
<li>普通股、优先股、认股权证（warrants）</li>
</ul>
</li>
<li><p>多个投资者</p>
<ul>
<li><p>共同基金</p>
<blockquote>
<p>open-end：直接向基金购买，<strong>基金净值 = 交易价格（即赎回）</strong></p>
<p>closed-end：在二级市场购买，<strong>实际交易价格受到二级市场供需关系影响</strong></p>
</blockquote>
</li>
<li><p>ETF &amp; ETN：类似于closed-end 基金，但 :question:</p>
</li>
<li><p>资产抵押债券（asset-backed security）：通过资产的收益来获得收益</p>
</li>
<li>对冲基金（hedge fund）：</li>
<li><p>契约（contracts）：约定在未来交易的契约</p>
<ul>
<li><p>远期契约（forward contracts）：约定在未来以特定价格进行交易</p>
</li>
<li><p>期货合约（future contracts）：类似于远期契约，但对单位进行标准化，在二级市场进行交易，因此拥有较高流动性。</p>
<blockquote>
<p>标准化的远期合约，可以不涉及实物交易。</p>
</blockquote>
</li>
<li><p>掉期合约（swap contracts）：约定在未来交换两项资产的收益。。。</p>
</li>
<li><p>期权合约（option contracts）：</p>
<ul>
<li>call：买的权力</li>
<li>put：卖的权利</li>
</ul>
</li>
<li><p>保险合约（insurance contracts）</p>
</li>
<li><p>信用违约交换（credit default swap）：对冲债券违约风险-</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>不动产</p>
<ul>
<li>优点：多元化收入；税收优惠</li>
<li>缺点：低流动性；专业性要求</li>
<li>间接购买不动产：房地产投资信托（REIT）</li>
</ul>
</li>
<li><p>金融中介</p>
<ul>
<li>经纪人<ul>
<li>block broker ：大单经纪人</li>
</ul>
</li>
<li>做市商：dealer</li>
<li>投行：帮助公司发行新股票、提供咨询服务</li>
<li>交易所：提供交易场所</li>
</ul>
</li>
</ul>
<h5 id="头寸和杠杆率"><a href="#头寸和杠杆率" class="headerlink" title="头寸和杠杆率"></a>头寸和杠杆率</h5><ul>
<li><p>多头和空头</p>
<ul>
<li>区别<ul>
<li>多头：价格上涨时获利</li>
<li>空头：价格下跌时获利</li>
</ul>
</li>
<li>资产持有者可以利用卖空头寸来在期货交易中对冲风险。<ul>
<li>卖空交易的细节<ul>
<li>分红怎么处理？——payments in lieu</li>
<li>卖空后交给经纪人托管的资金利息怎么处理？——short rebate rate</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>杠杆头寸：以借入资金的方式来购买资产</p>
<ul>
<li><p>关键要素</p>
<ul>
<li><p>初始购买金率（initial margin requirement）</p>
<blockquote>
<p>即杠杆率</p>
</blockquote>
</li>
<li><p>接入资金利息（call money rate）</p>
</li>
<li><p>佣金（commission）</p>
</li>
<li><p>应付保证金（maintenance margin requirement）</p>
</li>
</ul>
</li>
<li><p>收益计算</p>
</li>
<li><p>margin call 计算：<strong>保证借款部分不被资产价格降低而缩水</strong></p>
<ul>
<li>$P_1=P_0（1-I_i/1-I_m）$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="交易指令"><a href="#交易指令" class="headerlink" title="交易指令"></a>交易指令</h5><ul>
<li><p>买卖价格（站在做市商的视角）</p>
<ul>
<li><p>买价（bid price）：做市商购买资产的价格</p>
</li>
<li><p>卖价（ask/offer price）：做市商卖掉资产的价格</p>
</li>
<li><p>买卖价差（bid-ask spread）</p>
<blockquote>
<p>做市商的收益</p>
</blockquote>
</li>
</ul>
</li>
<li><p>交易指令</p>
<ul>
<li><p>执行指令（execution instruction）：<strong>如何交易？</strong></p>
<ul>
<li><p>市场指令（market order）：<strong>立即</strong>以市场当时的<strong>最优价格</strong>买入</p>
<blockquote>
<p>优点：投资者有市场尚未消化的信息时，希望立刻买入。流动性高</p>
<p>缺点：买卖价格未知，可能超预期</p>
</blockquote>
</li>
<li><p>限价指令（limit order）：根据指定价格买卖</p>
<blockquote>
<p>优点：明确收益</p>
<p>缺点：可能不能完成交易</p>
</blockquote>
</li>
<li><p>考虑成交量的指令</p>
</li>
<li>考虑交易公开性的指令</li>
</ul>
</li>
<li><p>有效指令（validity instruction）：<strong>何时交易？</strong></p>
<ul>
<li>当日有效</li>
<li>立即成交否则不成交委托：要么<strong>立即</strong>全部成交，要么<strong>不成交</strong></li>
<li>止损买单</li>
</ul>
</li>
<li><p>清算指令（clearing instruction）：<strong>如何结算？</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="市场类型"><a href="#市场类型" class="headerlink" title="市场类型"></a>市场类型</h5><h3 id="Security-market-indexs"><a href="#Security-market-indexs" class="headerlink" title="Security market indexs"></a>Security market indexs</h3><h5 id="证券指数的回报"><a href="#证券指数的回报" class="headerlink" title="证券指数的回报"></a>证券指数的回报</h5><ul>
<li>价格指数：反映组成的成分股的价格变化</li>
<li>总收益指数：组合期间内的收益，以及收益的收益</li>
</ul>
<h5 id="证券指数收益的赋权方式"><a href="#证券指数收益的赋权方式" class="headerlink" title="证券指数收益的赋权方式"></a>证券指数收益的赋权方式</h5><ul>
<li><p>price-weight：根据价格对收益进行加权</p>
<ul>
<li><p>收益计算：$p_1+p_2+p_3/n$</p>
<blockquote>
<p>  假设购买相同股份，每个股票的价格即为<strong>自己收益</strong>的权重。</p>
</blockquote>
</li>
<li><p>何时修正赋权（rebalance）</p>
</li>
<li><p>特点：</p>
<ul>
<li>价格高股票的变动影响更大。</li>
<li>当某只股票发生拆股时，由于股东的财富没有改变，<strong>因此，指数（price-weighted）不应改变，应对调整分母股票的数量</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>equal-weight：不对收益进行加权（un-weighted）</p>
<ul>
<li><p>收益计算：</p>
<ul>
<li>算术平均法：$R_A+R_B+R_C/n$</li>
<li><p>指数平均法：$(R_A+R_B+R_C)^{(1/n)}$</p>
<blockquote>
<p>  假设购买相同股份，每个股票的权重相同。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>每只股票的收益率都对最终的收益有相同的影响。</li>
<li><strong>小盘股票的波动可能更加剧烈，因此对最终的指数收益可能影响更大。</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>capitalization-weight：根据市值对收益加权</p>
<ul>
<li><p>如何计算收益：市值之比</p>
</li>
<li><p>特点</p>
<ul>
<li><p>不用对股票分拆及股利发放进行调整</p>
</li>
<li><p>解决了高价格股票和小盘口股票带来的偏差，但也带来了新的偏差：</p>
<ul>
<li><p>但未流通的股票也会带来偏差</p>
<blockquote>
<p>  float-adjusted ：只对实际流通的股票进行计算。</p>
</blockquote>
</li>
<li><p>股票价值被不均等的高估</p>
<blockquote>
<p>  基本面加权：利用公司财务指标来加权</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="对指数进行调整"><a href="#对指数进行调整" class="headerlink" title="对指数进行调整"></a>对指数进行调整</h5><ul>
<li>rebalance：股票<strong>价格的变动</strong>导致其在指数中的权重偏离既定目标值。<ul>
<li>调整是通过买卖股票实现的。<strong>买卖是有成本的，</strong>所以不能频繁调整。</li>
<li>什么类型的指数需要rebalance：<ul>
<li>对于<strong>价格指数</strong>和<strong>市值指数</strong>，价格变动自动带来权重调整。（因为目标值就包含了价格因素！）</li>
<li>对位<strong>等权重指数</strong>，如果价格没有等比例变化，那么权重就会改变</li>
</ul>
</li>
</ul>
</li>
<li>reconstitution：如果股票不具有代表性了，就应当删除。</li>
</ul>
<h5 id="主流指数"><a href="#主流指数" class="headerlink" title="主流指数"></a>主流指数</h5><ul>
<li>股票指数<ul>
<li>大盘指数：衡量大盘整体表现的方法，通常包含市场90%以上的总市值</li>
<li>多市场指数：专注细分市场<ul>
<li>以基本面为权重的多市场指数：如以国家GDP进行加权</li>
</ul>
</li>
<li>行业指数</li>
<li>风格指数：划分不同的投资风格来区分指数市场</li>
</ul>
</li>
<li>固定收益指数<ul>
<li>相较于股票指数：<ul>
<li>范围更大：对于债券市场，政府也可放债。</li>
<li>交易不活跃：价格信息不准确</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="其它投资指数"><a href="#其它投资指数" class="headerlink" title="其它投资指数"></a>其它投资指数</h5><ul>
<li>房地产</li>
<li>大宗商品：以期货数据为依据计算</li>
<li>对冲基金<ul>
<li>由于样本选择性偏误，<strong>对冲基金指数并不能真实地反映对冲基金的业绩</strong></li>
</ul>
</li>
</ul>
<h3 id="Market-Efficiency"><a href="#Market-Efficiency" class="headerlink" title="Market Efficiency"></a>Market Efficiency</h3><p><strong>「有效市场中，价格反映了所有过去、现在、公开、非公开的信息，并且会迅速对新的信息作出反映」</strong></p>
<blockquote>
<p>  :star:理解三种形式的市场有效性</p>
</blockquote>
<h5 id="认识有效市场"><a href="#认识有效市场" class="headerlink" title="认识有效市场"></a>认识有效市场</h5><ul>
<li>通过交易行为来反映市场有效程度</li>
<li>有效市场中，市场价值=内在价值</li>
<li>高度有效市场的特征<ul>
<li>参与者多</li>
<li>信息易于获取</li>
<li>交易限制少：<strong>是否允许套利和做空</strong></li>
<li>交易成本、信息获取成本低</li>
</ul>
</li>
</ul>
<h5 id="三种类型的有效市场"><a href="#三种类型的有效市场" class="headerlink" title="三种类型的有效市场"></a>三种类型的有效市场</h5><ul>
<li>强势有效：价格反映所有信息<ul>
<li><strong>所有分析都失效</strong>，没有办法获取超额收益</li>
</ul>
</li>
<li>半强势有效：价格反映所有公开信息（市场或非市场）<ul>
<li><strong>技术分析</strong>失效，<strong>基本面分析</strong>部分失效</li>
</ul>
</li>
<li>弱势有效：价格反映市场信息<ul>
<li>投资者不可能通过分析以往价格获得超额利润：<strong>技术分析失效</strong></li>
</ul>
</li>
</ul>
<h5 id="市场反常（abnormal）"><a href="#市场反常（abnormal）" class="headerlink" title="市场反常（abnormal）"></a>市场反常（abnormal）</h5><ul>
<li>根据市场有效性假说，任何一种股票或其组合的<strong>平均超额收益</strong>都该为零。如果出现超额收益，并不能否认市场有效性，因为有很多人为因素。</li>
</ul>
<h5 id="行为金融学"><a href="#行为金融学" class="headerlink" title="行为金融学"></a>行为金融学</h5><ul>
<li>已确认的行为偏差<ul>
<li>损失厌恶：风险与收益偏好的非对称：损失的痛苦大于收益的喜悦</li>
<li>过度自信：高估自己的分析能力</li>
</ul>
</li>
</ul>
<h3 id="Overview-of-Equity-Securities"><a href="#Overview-of-Equity-Securities" class="headerlink" title="Overview of Equity Securities"></a>Overview of Equity Securities</h3><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><ul>
<li><p>权益投资类别</p>
<ul>
<li><p>普通股（common shares）</p>
<ul>
<li>在债权和优先股后对公司剩余资产具有申索权</li>
<li>投票权：理事会；公司重大事项</li>
</ul>
<blockquote>
<p>按照投票权分为A类、B类普通股：</p>
<ul>
<li>投票权不同</li>
<li>清算时申索权不同</li>
</ul>
</blockquote>
</li>
<li><p>优先股（preferrence shares）</p>
<ul>
<li>一般具有周期性的固定收益</li>
<li><p>一般不具有投票权</p>
</li>
<li><p>可以按预定价格进行回购（callable）会回售（putable）</p>
</li>
</ul>
<blockquote>
<p>累积优先股（cumulative preference shares）：</p>
<ul>
<li>固定分红，如果没有，后期将在普通股分红前进行补偿</li>
</ul>
<p>非累积优先股（non cumulative preference shares）</p>
<ul>
<li>固定丰厚，如果错过，后期不补。但如果有，将在普通股分红前获得分红</li>
</ul>
<hr>
<p>参与管理优先股（participating preference share）</p>
<ul>
<li>公司收益时，获取超过预定分红比率的分红</li>
<li>公司清算时，获取更高份额的回报</li>
</ul>
<p>不参与管理优先股（non-participating share）</p>
<ul>
<li>对公司利润没有申索权</li>
</ul>
</blockquote>
</li>
<li><p>可兑换优先股（convertible preferred shares）：可转换成普通股</p>
<ul>
<li>一般比普通股具有更高分红，且更小风险。</li>
</ul>
<blockquote>
<p>如果公司盈利：普通股价格上升，转换成普通股以获得收益</p>
<p>如果公司不盈利：保持较高分红、低风险</p>
</blockquote>
</li>
</ul>
</li>
<li><p>私募股权与公募股权的区别</p>
<ul>
<li>私募股权主要面向机构投资者</li>
<li>与公募股权的区别：<ul>
<li>流动性更差：不存在公开交易市场</li>
<li>协定议价：不存在公开定价</li>
<li>更少的公司财务信息披露<ul>
<li>公司治理、披露成本、</li>
</ul>
</li>
<li>更能专注长期目标</li>
<li>可能具有高额收益</li>
</ul>
</li>
</ul>
</li>
<li>风险投资</li>
<li><p>杠杆收购（leveraged buyout, LBO）：利用债务融资来进行收购</p>
<ul>
<li>收购方为管理层：MBO</li>
</ul>
</li>
<li>上市后私募增发（PIPE）：向投资者以市场价的折后价出售私人股权。</li>
</ul>
<h5 id="国外权益与权益风险"><a href="#国外权益与权益风险" class="headerlink" title="国外权益与权益风险"></a>国外权益与权益风险</h5><ul>
<li><p>投资国外权益的方式</p>
<ul>
<li><p>直接投资：直接在当地公开市场购买权益</p>
<ul>
<li>外币结算</li>
<li>环境法规风险</li>
</ul>
</li>
<li><p>间接投资：</p>
<blockquote>
<p>存托凭证（deposit receipts）：在某公司非发行地的股权。一般由投资者所在地的银行代理</p>
<ul>
<li>有人购买：sponsored DR</li>
<li>无人购买：unsponsored DR，由银行获取投票权</li>
</ul>
</blockquote>
<ul>
<li><p>全球存托凭证（GDRs）：既不在美国、也不再股票发行地</p>
<blockquote>
<p>一般在伦敦或者卢森堡：使用美元交易、没有环境法规限制。</p>
</blockquote>
</li>
<li><p>美国存托凭证（ADRs）：美国交易、美元计价，除私人交易其他均需要符合美国制度要求</p>
</li>
<li><p>全球注册股权（GRSs）：全球交易</p>
</li>
<li><p>一揽子存托凭证（BLDR）：一揽子DR一起交易。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="权益收益"><a href="#权益收益" class="headerlink" title="权益收益"></a>权益收益</h5><ul>
<li><p>组成部分：价格变动+分红+汇率</p>
</li>
<li><p>风险比较</p>
<ul>
<li>优先股 &lt; 普通股</li>
<li>累计优先股 &lt; 非累积优先股</li>
<li>可回售 &lt; 可赎回</li>
</ul>
</li>
<li><p>权益计价：权益市值（market value of equity）≠ 权益账面价值（book value of equity）</p>
<ul>
<li>ROE：<strong>扣除优先股分红后</strong>的普通股收益/期间内平均账面价值</li>
<li>price-to-book ratio：权益市值/权益账面价值<ul>
<li>反应股票的相对价值：PB越低，公司股价可能被低估。</li>
</ul>
</li>
</ul>
</li>
<li>权益成本：包含分红的所有在市场流通股权的收益</li>
<li>投资者预期收益：公司的内在价值等于未来现金流的折现值<ul>
<li>预期收益越高（折现率越高），折现价值越低。反之，股价降低了，对未来的预期收益率提高。</li>
</ul>
</li>
</ul>
<h3 id="Introduction-to-Industry-and-Company-Analysis"><a href="#Introduction-to-Industry-and-Company-Analysis" class="headerlink" title="Introduction to Industry and Company Analysis"></a>Introduction to Industry and Company Analysis</h3><p>「明确行业、理解企业周期、行业战略分析、议价能力、公司竞争战略」</p>
<h5 id="行业分析"><a href="#行业分析" class="headerlink" title="行业分析"></a>行业分析</h5><p>「所在不同行业的企业不使用同一基本面分析」</p>
<ul>
<li>分类机构<ul>
<li>政府制定：</li>
<li>商业公司制定：主要依据企业产品与服务</li>
</ul>
</li>
<li>行业分析的要素<ul>
<li>理解宏观经济变量与行业趋势的关系</li>
<li>基于不同情形对行业的重要参数进行预测</li>
<li>评估不同行业的相对价值</li>
<li>识别行业内不同类型的企业，并对其未来进行预测</li>
<li>判断行业所处的周期</li>
<li>识别行业的经验曲线（experience curve）</li>
<li>理解影响行业的重要因素：宏观经济、人口、技术、社会</li>
<li>理解行业竞争的决定性因素</li>
</ul>
</li>
<li>行业分析工具：波特五力模型<ul>
<li>现存竞争对手</li>
<li>潜在进入者</li>
<li>替代者</li>
<li>下游市场购买力</li>
<li>上游市场供给能力</li>
</ul>
</li>
</ul>
<h5 id="企业分析：议价权（竞争力）"><a href="#企业分析：议价权（竞争力）" class="headerlink" title="企业分析：议价权（竞争力）"></a>企业分析：议价权（竞争力）</h5><ul>
<li>不同类型市场下的企业议价权<ul>
<li>进入、退出门槛：<ul>
<li>进入门槛越高，竞争越小，议价权越大（<strong>不绝对</strong>，同质化商品）</li>
<li>退出门槛越高，竞争越大，议价权越小</li>
</ul>
</li>
<li>市场集中度：越集中，竞争越小</li>
<li>行业产能：是否供过于求？</li>
<li>市场份额稳定性</li>
</ul>
</li>
<li>行业生命周期<ul>
<li>萌芽期（embryonic）：竞争小、成长慢、价格高、风险高</li>
<li>成长期（growth）：竞争较小、成长快、价格开始下降</li>
<li>shakeout：竞争大、产能过剩、利润下降、成长减速</li>
<li>成熟期：进入寡头竞争、成长慢、进入门槛高</li>
<li>衰退期：负增长、价格下降、企业退出</li>
</ul>
</li>
<li>公司竞争战略<ul>
<li>低成本：低价以获取市场</li>
<li>差异化：公司差异化产品提供的增量不能高于成本的增量</li>
</ul>
</li>
</ul>
<h3 id="Equity-valuation：concepts-and-basic-tools"><a href="#Equity-valuation：concepts-and-basic-tools" class="headerlink" title="Equity valuation：concepts and basic tools"></a>Equity valuation：concepts and basic tools</h3><h5 id="权益估值模型"><a href="#权益估值模型" class="headerlink" title="权益估值模型"></a>权益估值模型</h5><ul>
<li>折扣现金流模型：该投资未来所有现金流的贴现<ul>
<li>股利折现模型：<strong>未来派发给股东的股利</strong>的折现</li>
<li>自由现金流模型：企业扣除<strong>资本开支</strong>和<strong>周转开支</strong>后可供股东分配的现金流</li>
</ul>
</li>
<li>乘数模型<ul>
<li>基于股票价格的乘数：股价与公司基本面数据的比率（P/B）</li>
<li>基于企业价值的乘数：企业价值与企业收益的比率（企业价值与EBITDA的比率）</li>
</ul>
</li>
<li>资产模型<ul>
<li>普通股的内在价值=总资产-（负债+优先股）</li>
</ul>
</li>
</ul>
<h5 id="股利"><a href="#股利" class="headerlink" title="股利"></a>股利</h5><ul>
<li><p>现金股利</p>
</li>
<li><p>股票股利</p>
<blockquote>
<p>  与股票分拆的异同：</p>
<ul>
<li>相同：每股市价降低，股东总权益不变</li>
<li>不同：每股账面价值不同，股东权益结构改变，股东财富增加。</li>
</ul>
</blockquote>
</li>
</ul>
<h5 id="折扣现金流模型"><a href="#折扣现金流模型" class="headerlink" title="折扣现金流模型"></a>折扣现金流模型</h5><ul>
<li>具体操作<ul>
<li>固定股利贴现</li>
<li>固定增速股利贴现</li>
<li>含有高增速阶段的固定增速股利贴现</li>
</ul>
</li>
<li>优缺点<ul>
<li>优点：具有理论和现实意义</li>
<li>缺点：结果对输入的估计值敏感</li>
</ul>
</li>
</ul>
<h5 id="乘数模型"><a href="#乘数模型" class="headerlink" title="乘数模型"></a>乘数模型</h5><ul>
<li><p>具体操作</p>
<ul>
<li><p>基于公司的乘数模型：</p>
</li>
<li><p>基于基本面的乘数模型：$\frac{P_0}{E_1}=\frac{D_1/E_1}{k-g}$</p>
<blockquote>
<ul>
<li>调整的PE：针对未来收益（现金流）的PE，不是基于历史数据计算的</li>
<li>为判断公司的乘数提供标准</li>
</ul>
</blockquote>
</li>
<li><p>基于企业价值（EV）的乘数模型：$EV/EBITDA$</p>
</li>
</ul>
</li>
<li><p>优缺点</p>
<ul>
<li>优点：①指数易于获取</li>
<li>缺点：①无法对周期性企业比较；②无法对不同规模等的企业比较；③不能有负值（除基于企业价值的乘数模型外）</li>
</ul>
</li>
</ul>
<h5 id="资产模型"><a href="#资产模型" class="headerlink" title="资产模型"></a>资产模型</h5><ul>
<li>具体操作<ul>
<li>利用资产负债表计算：企业资产总市值 - 企业负债总市值</li>
</ul>
</li>
<li>优缺点：<ul>
<li>优点：①提供企业的最低估值；</li>
<li>缺点：①缺乏对无形资产的衡量；②不适用于超级通胀的环境</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>CFA</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
