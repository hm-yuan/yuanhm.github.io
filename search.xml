<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>show me the money</title>
    <url>/2020/07/22/show-me-the-money/</url>
    <content><![CDATA[<p>show me the money</p>
]]></content>
  </entry>
  <entry>
    <title>[Advanced R] Ⅰ. 名称与对象</title>
    <url>/2020/08/02/Advanced_R/2.%20Names_and_Values/</url>
    <content><![CDATA[<h2 id="Names-and-Values"><a href="#Names-and-Values" class="headerlink" title="Names and Values"></a>Names and Values</h2><blockquote>
<p>  <strong>对象（object）并没有名字（name），只是名字有了对象」</strong></p>
</blockquote>
<h3 id="名字与对象的链接"><a href="#名字与对象的链接" class="headerlink" title="名字与对象的链接"></a>名字与对象的链接</h3><p>名字和对象是独立的，二者通过<code>&lt;-</code>相连。</p>
<ul>
<li>每个对象在R中都有自己的编号（如下的 “0x1deba3bd8f8”）。</li>
<li>名字与对象直接相连，名字只是对象的<strong>查询编码（Reference）</strong>：<img src="https://d33wubrfki0l68.cloudfront.net/bdc72c04d3135f19fb3ab13731129eb84c9170af/f0ab9/diagrams/name-value/binding-2.png" srcset="/img/loading.gif" style="zoom: 33%;" /></li>
</ul>
<pre><code class="hljs &#123;r&#125;"># 变量与对象的关系
x &lt;- c(1, 2, 3)
y &lt;- x

# x, y实际指向了同一个对象
lobstr::obj_addr(x)
# [1] &quot;0x1deba3bd8f8&quot;
lobstr::obj_addr(y)
# [1] &quot;0x1deba3bd8f8&quot;</code></pre>
<h3 id="Copy-on-modify"><a href="#Copy-on-modify" class="headerlink" title="Copy-on-modify"></a>Copy-on-modify</h3><ol>
<li><p><strong>Basic：</strong>对象是不可修改的，<strong>只能对复制的对象进行修改（Copy-on-modify）</strong></p>
<ul>
<li><p>修改y并不会改变x的值，只是通过复制对象，并在复本的基础上新生成了一个对象：<img src="https://d33wubrfki0l68.cloudfront.net/ef9f480effa2f1d0e401d1f94218d0cf118433c0/b56e9/diagrams/name-value/binding-3.png" srcset="/img/loading.gif" style="zoom:33%;" /></p>
<pre><code class="hljs &#123;r&#125;"># 追踪x对象：如果复制发生，则将通知
tracemem(x)
#&gt; [1] &quot;&lt;000001DEBA3BD8F8&gt;&quot;
y[[3]] &lt;- 4L
#&gt; tracemem[0x000001deba3bd8f8 -&gt; 0x000001deba3b0d58]:

# 修改y并不会改变x的值
x
#&gt; [1] 1 2 3
y
#&gt; [1] 1 2 4

# 修改y实际上新生成了一个变量
lobstr::obj_addr(y)
#&gt; [1] &quot;0x1deba3b0d58&quot;</code></pre>
</li>
</ul>
</li>
<li><p><strong>Function：</strong>函数（Function）中的对象同样使用<strong>Copy-on-modify</strong>准则</p>
<ul>
<li><p>函数的运行结果相当于建立了新的链接，其中没有涉及复制：<img src="https://d33wubrfki0l68.cloudfront.net/e8718027aabaed377da311f45b45a179588e4dcf/6bf90/diagrams/name-value/binding-f2.png" srcset="/img/loading.gif" style="zoom:33%;" /></p>
<pre><code class="hljs &#123;r&#125;">f &lt;- function(a) a
x &lt;- c(1, 2, 3)
tracemem(x)
z &lt;- f(x)
# 没有复制发生！</code></pre>
</li>
</ul>
</li>
<li><p><strong>List：</strong>列表（list）指向的不是值（value），而是查询编码（Reference）的集合</p>
<ul>
<li><p>当修改发生时，只是修改部分查询编码的指向：<img src="https://d33wubrfki0l68.cloudfront.net/b844bb5a3443e1344299627f5760e2ae3a9885b5/e1c76/diagrams/name-value/l-modify-2.png" srcset="/img/loading.gif" style="zoom: 33%;" /></p>
<pre><code class="hljs &#123;r&#125;">l1 &lt;- c(1, 2, 3)
l2 &lt;- l1
l2[[3]] &lt;- 4L
lobstr:ref(l1, l2)
#&gt; o [1:0x1deb8aecdf0] &lt;list&gt; 
#&gt; +-[2:0x1deba502740] &lt;dbl&gt; 
#&gt; +-[3:0x1deba502778] &lt;dbl&gt; 
#&gt; \-[4:0x1deba5027b0] &lt;dbl&gt; 
 
#&gt; o [5:0x1deba41de78] &lt;list&gt; 
#&gt; +-[2:0x1deba502740] 
#&gt; +-[3:0x1deba502778] 
#&gt; \-[6:0x1deba5f0fd0] &lt;int&gt;</code></pre>
</li>
</ul>
</li>
<li><p><strong>Date Frame：</strong>数据框（Data frames）是向量的列表（list of vectors），适用相同的规制</p>
<ul>
<li>修改列时：仅有<strong>被修改的列指向的对象</strong>会发生改变。</li>
<li>修改行时：<strong>所有列指向的对象</strong>都发生了改变。</li>
</ul>
</li>
<li><p><strong>Character vectors：</strong>字符串向量（Character vectors）指向的是在全局中包含多种字符串的池。当修改发生时，是部分字符串的查询编码发生了改变，因而总体的对象也不同了</p>
<pre><code class="hljs &#123;r&#125;">x &lt;- c(&quot;a&quot;, &quot;a&quot;, &quot;abc&quot;, &quot;d&quot;)
y &lt;- x
y[[1]] &lt;- &quot;c&quot;
# 指向的对象不同了
ref(x, y)
#&gt; [1:0x1deb8b09248] &lt;chr&gt; 

#&gt; [2:0x1deb8ab1b10] &lt;chr&gt; 

# 实际是具体修改的字符串查询编码变化了
ref(x, y, character &#x3D; T)
#&gt; o [1:0x1deb8b09248] &lt;chr&gt; 
#&gt; +-[2:0x1deb133d720] &lt;string: &quot;a&quot;&gt; 
#&gt; +-[2:0x1deb133d720] 
#&gt; +-[3:0x1deb550c728] &lt;string: &quot;abc&quot;&gt; 
#&gt; \-[4:0x1deb150d048] &lt;string: &quot;d&quot;&gt; 
 
#&gt; o [5:0x1deb8ab1b10] &lt;chr&gt; 
#&gt; +-[6:0x1deb00e29f0] &lt;string: &quot;c&quot;&gt; 
#&gt; +-[2:0x1deb133d720] 
#&gt; +-[3:0x1deb550c728] 
#&gt; \-[4:0x1deb150d048]</code></pre>
</li>
</ol>
<h3 id="对象的大小（Object-size）"><a href="#对象的大小（Object-size）" class="headerlink" title="对象的大小（Object size）"></a>对象的大小（Object size）</h3><ol>
<li><p>由于列表（list）实质上是储存了对象的查询编码，所以列表的大小可能远小于预期。</p>
<pre><code class="hljs &#123;r&#125;">x &lt;- runif(1e6)
lobstr::obj_size(x)
#&gt; 8,000,048 B
y &lt;- list(x, x, x)
lobstr::obj_size(y)
#&gt; 8,000,128 B</code></pre>
</li>
<li><p>由于R中的字符串同样采用类似于list的字符串池（string pool）的方式，所以重复字符串后的大小也小于预期。</p>
<pre><code class="hljs &#123;r&#125;">banana &lt;- &quot;bananas bananas bananas&quot;
obj_size(banana)
#&gt; 136 B
obj_size(rep(banana, 100))
#&gt; 928 B</code></pre>
</li>
<li><p>变量相加后的大小类似于<strong>并集</strong>的关系，如果二者没有相同的值，那么对象相加后的大小就等于两个单独的大小相加。</p>
</li>
</ol>
<h3 id="立即修改"><a href="#立即修改" class="headerlink" title="立即修改"></a>立即修改</h3><p>并非所有对对象的修改都是<strong>copy-on-modify</strong>，有两类例外，他们是<strong>将对象本身立即修改的（modify-in-place）</strong>：</p>
<ol>
<li><p>仅有单一链接（binding）的对象</p>
<p>单一链接（binding）的对象会直接对自身进行修改。但每次使用常规函数时，都会将对象的链接增加，并且不能再回到1。</p>
<p>事实上，R中循环（loops）的缓慢正是因为其不断地在复制对象。<strong>此时可以考虑将data.frame转换为list来进入循环，因为list允许单独修改某一查询编码（Reference）。</strong></p>
<pre><code class="hljs &#123;r&#125;">x &lt;- data.frame(matrix(runif(5 * 1e4), ncol &#x3D; 5))
medians &lt;- sapply(x, median, numeric(i))
tracemem(x)
#&gt; [1] &quot;&lt;000001402BEBE6B0&gt;&quot;

# 直接使用循环，对象在每次迭代中被复制了两次
for (i in seq_along(medians)) x[[i]] &lt;- x[[i]] - medians[[i]]
#&gt; tracemem[0x000001402bebe6b0 -&gt; 0x0000014029bcf0b0]: 
#&gt; tracemem[0x0000014029bcf0b0 -&gt; 0x0000014029bcf190]: [[&lt;-.data.frame [[&lt;- 
#&gt; tracemem[0x0000014029bcf190 -&gt; 0x0000014029bcf580]: 
#&gt; tracemem[0x0000014029bcf580 -&gt; 0x0000014029bcf6d0]: [[&lt;-.data.frame [[&lt;- 
#&gt; tracemem[0x0000014029bcf6d0 -&gt; 0x0000014029b9d750]: 
#&gt; tracemem[0x0000014029b9d750 -&gt; 0x0000014029b9d9f0]: [[&lt;-.data.frame [[&lt;- 
#&gt; tracemem[0x0000014029b9d9f0 -&gt; 0x0000014029b9dfa0]: 
#&gt; tracemem[0x0000014029b9dfa0 -&gt; 0x0000014029b9e160]: [[&lt;-.data.frame [[&lt;- 
#&gt; tracemem[0x0000014029b9e160 -&gt; 0x0000014029b9e550]: 
#&gt; tracemem[0x0000014029b9e550 -&gt; 0x0000014029b9ea90]: [[&lt;-.data.frame [[&lt;- 

# 将data.frame转换为list，仅有一次复制发生
y &lt;- as.list(x)
#&gt; tracemem[0x0000014029b9ea90 -&gt; 0x000001402f1245e0]: as.list.data.frame as.list 
for (i in seq_along(medians)) y[[i]] &lt;- y[[i]] - medians[[i]]
#&gt; tracemem[0x000001402f1245e0 -&gt; 0x000001402f47f7c0]:</code></pre>
</li>
</ol>
<ol>
<li><p>环境（environment）</p>
<p>环境（environment）是一种特殊的对象，实质是多个对象和名称链接的集合，它总是立即修改的（modify-in-place）。</p>
<pre><code class="hljs &#123;r&#125;">e1 &lt;- rlang::env(a &#x3D; 1, b &#x3D; 2, c &#x3D; 3)
e2 &lt;- e1

# 修改e1中的对象后，e2同步改变了
e1$c &lt;- 4
e2$c
#&gt; [1] 4</code></pre>
</li>
</ol>
<h3 id="清理内存"><a href="#清理内存" class="headerlink" title="清理内存"></a>清理内存</h3><p>使用<code>rm( )</code>只能删去名称与对象的链接，并不能删去对象。</p>
<ul>
<li>使用<code>gc( )</code>来清理内存，<code>gcinfo( TRUE )</code>来显示每次计算机清理内存的操作。</li>
<li>使用<code>men_used( )</code>来查看已消耗的内存。</li>
</ul>
<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://adv-r.hadley.nz/" target="_blank" rel="noopener">《Advanced R》</a>学习笔记。
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>[Advanced R] Ⅰ. 向量</title>
    <url>/2020/08/03/Advanced_R/3.%20Vectors/</url>
    <content><![CDATA[<h2 id="Vectors"><a href="#Vectors" class="headerlink" title="Vectors"></a>Vectors</h2><blockquote>
<p>  <strong>向量由</strong>原子向量（atomic vector）<strong>和</strong>列表（list）<strong>组成，二者的区别在于：原子向量中的每个元素具有相同的类别，而列表中元素的类别可以不同。</strong></p>
</blockquote>
<p><img src="https://d33wubrfki0l68.cloudfront.net/2ff3a6cebf1bb80abb2a814ae1cfc67b12817713/ae848/diagrams/vectors/summary-tree.png" srcset="/img/loading.gif" style="zoom:33%;" /></p>
<h3 id="原子向量"><a href="#原子向量" class="headerlink" title="原子向量"></a>原子向量</h3><p>原子向量（atomic vector）有四种基础类别：logical，integer，double，character。</p>
<p><img src="https://d33wubrfki0l68.cloudfront.net/eb6730b841e32292d9ff36b33a590e24b6221f43/57192/diagrams/vectors/summary-tree-atomic.png" srcset="/img/loading.gif" style="zoom:33%;" /></p>
<ul>
<li><p>绝大多数情况下与缺失值（<code>NA</code>）相关的表达式输出的都是<code>NA</code>。</p>
<pre><code class="hljs &#123;r&#125;">NA &gt; 5
#&gt; [1] NA
10 * NA
#&gt; [1] NA
!NA
#&gt; [1] NA

# 以下为特殊情况
NA ^ 0
#&gt; [1] 1
NA | TRUE
#&gt; [1] TRUE
NA &amp; FALSE
#&gt; [1] FALSE</code></pre>
</li>
<li><p>由于原子向量中的所有元素具有相同的属性，当试图合并两个不同类别的向量时，<strong>R</strong>会自动按照一个固定的顺序来强行调整类别（coerce）：<strong>character → double → integer → logical</strong>。对于logical向量，在使用数学函数时，其会自动转换为numeric。当强行调整类别失败时，<strong>R</strong>会返回NA。</p>
<pre><code class="hljs &#123;r&#125;">str(c(&quot;a&quot;, 1))
#&gt;  chr [1:2] &quot;a&quot; &quot;1&quot;

# 对于logical向量，在使用数学函数时，其会自动转换为numeric
x &lt;- c(FALSE, FALSE, TRUE)
as.numeric(x)
#&gt; [1] 0 0 1
sum(x)
#&gt; [1] 1

# 当强行调整类别失败时，R会返回NA
as.integer(c(&quot;1&quot;, &quot;1.5&quot;, &quot;a&quot;))
#&gt; Warning: NAs introduced by coercion
#&gt; [1]  1  1 NA</code></pre>
</li>
</ul>
<h3 id="属性（Attributes）"><a href="#属性（Attributes）" class="headerlink" title="属性（Attributes）"></a>属性（Attributes）</h3><p>属性（Attributes）能够使原子向量变为更多的其它类型。</p>
<ul>
<li><p>使用<code>attr( )</code>来获取和编辑单个属性，使用<code>attributes( )</code>来获取对象的所有属性信息。</p>
</li>
<li><p>属性（Attributes）只是暂时的，绝大多数基本的操作都会使对象丧失属性。</p>
<pre><code class="hljs &#123;r&#125;">a &lt;- 1:3
attr(a, &quot;x&quot;) &lt;- &quot;abc&quot;
attr(a, &quot;x&quot;)
#&gt; [1] &quot;abc&quot;

# 丧失属性
attributes(a[1])
#&gt; NULL</code></pre>
</li>
<li><p>名字（name）和维度（dim）是仅有的两个会提前预设的属性。</p>
<pre><code class="hljs &#123;r&#125;"># 三种命名方式
x &lt;- c(a &#x3D; 1, b &#x3D; 2, c &#x3D; 3)

x &lt;- 1:3
names(x) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)

x &lt;- setNames(1:3, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))
# 可使用unname(x)或names(x) &lt;- NULL 来去掉名称</code></pre>
<ul>
<li><p>增加维度（dim）使得向量升级为矩阵（matrix）或数组（array）。一般而言，适用于向量的函数，也有其在矩阵和数组中的形式</p>
<p>|    Vector    |         Matrix         |     Array      |<br>| :—————: | :——————————: | :——————: |<br>|    ames()    | rownames(), colnames() |   dimnames()   |<br>|    gth()`    |     nrow(), ncol()     |     dim()      |<br>|     c()      |    rbind(), cbind()    | abind::abind() |<br>|      —       |          t()           |    aperm()     |<br>| null(dim(x)) |      is.matrix()       |   is.array()   |</p>
</li>
</ul>
</li>
</ul>
<h3 id="S3原子向量"><a href="#S3原子向量" class="headerlink" title="S3原子向量"></a>S3原子向量</h3><p>拥有<strong>class</strong>的向量即转换成了<strong>S3对象（S3 object）</strong>，有四种重要的S3对象：</p>
<ul>
<li><p>类别变量（category data）：<strong>factor</strong>是基于integer的S3对象，内含提前预设的值。</p>
<pre><code class="hljs &#123;r&#125;"># 基于integer的对象
x &lt;- factor(c(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;a&quot;))
typeof(x)
#&gt; [1] &quot;integer&quot;
class(x)
#&gt; [1] &quot;factor&quot;

attributes(x)
#&gt; $levels
#&gt; [1] &quot;a&quot; &quot;b&quot;

#&gt; $class
#&gt; [1] &quot;factor&quot;

# factor中规定的level数量可多余实际对象中的元素类别数量
x &lt;- factor(x, levels &#x3D; c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))
table(x)
#&gt; x
#&gt; a b c 
#&gt; 2 2 0</code></pre>
</li>
<li><p>日期（dates）：<strong>Date</strong>是基于double的S3对象，是距离1970-01-01的天数。</p>
<pre><code class="hljs &#123;r&#125;">typeof(Sys.Date())
#&gt; [1] &quot;double&quot;
class(Sys.Date())
#&gt; [1] &quot;Date&quot;
unclass(Sys.Date())
#&gt; [1] 18477</code></pre>
</li>
<li><p>时间（date-times）：<strong>POSIXct</strong>和<strong>POSIXlt</strong>是基于double构建的S3对象。</p>
<pre><code class="hljs &#123;r&#125;">now_ct &lt;- as.POSIXct(&quot;2018-08-01 22:00&quot;, tz &#x3D; &quot;UTC&quot;)
now_ct
#&gt; [1] &quot;2018-08-01 22:00:00 UTC&quot;

typeof(now_ct)
#&gt; [1] &quot;double&quot;
attributes(now_ct)
#&gt; $class
#&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot; 
#&gt; 
#&gt; $tzone
#&gt; [1] &quot;UTC&quot;</code></pre>
</li>
<li><p>区间（durations）：<strong>difftime</strong>是基于double构建的S3对象。</p>
<pre><code class="hljs &#123;r&#125;">one_week_1 &lt;- as.difftime(1, units &#x3D; &quot;weeks&quot;)
one_week_1
#&gt; Time difference of 1 weeks
typeof(one_week_1)
#&gt; [1] &quot;double&quot;
attributes(one_week_1)
#&gt; $class
#&gt; [1] &quot;difftime&quot;
#&gt; 
#&gt; $units
#&gt; [1] &quot;weeks&quot;</code></pre>
</li>
</ul>
<h3 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h3><p>使用<code>list( )</code>来生成列表，使用<code>as.list( )</code>来将对象转换为列表。</p>
<h3 id="Data-Frame-amp-Tibbles"><a href="#Data-Frame-amp-Tibbles" class="headerlink" title="Data Frame &amp; Tibbles"></a>Data Frame &amp; Tibbles</h3><p>Data Frame和Tibbles是构建在list基础上的两个重要S3对象。</p>
<ul>
<li><p>Data Frame和Tibbles的重要区别在于tibble从不强制修改其输入项。</p>
<ul>
<li><p>Data Frame会自动修改无效变量名，tibbles不会修改。</p>
</li>
<li><p>Data Frame和tibble都会自动循环填充较短的变量，但是tibble只有在变量为1的时候才会循环填充。</p>
</li>
<li><p>tibble在创建变量时即可引用</p>
<pre><code class="hljs &#123;r&#125;">tibble(
  x &#x3D; 1:3,
  y &#x3D; x * 2
)
#&gt; # A tibble: 3 x 2
#&gt;       x     y
#&gt;   &lt;int&gt; &lt;dbl&gt;
#&gt; 1     1     2
#&gt; 2     2     4
#&gt; 3     3     6</code></pre>
</li>
</ul>
</li>
<li><p>tibbles不支持行名称，相反，其提供<code>rownames_to_column( )</code>和<code>rownames</code>来将现有的行名称转换为变量。</p>
</li>
<li><p>只要确保行数相同，就可以添加matrix或array到原data.frame</p>
<pre><code class="hljs &#123;r&#125;">dfm &lt;- data.frame(x &#x3D; 1:3 * 10)
dfm$y &lt;- matrix(1:9, nrow &#x3D; 3) #矩阵变量
dfm$z &lt;- data.frame(a &#x3D; 3:1, b &#x3D; letters[1:3], stringsAsFactors &#x3D; FALSE) #data.frame变量

str(dfm)
#&gt; &#39;data.frame&#39;:	3 obs. of  3 variables:
#&gt;  $ x: num  10 20 30
#&gt;  $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9
#&gt;  $ z:&#39;data.frame&#39;:	3 obs. of  2 variables:
#&gt;   ..$ a: int  3 2 1
#&gt;   ..$ b: chr  &quot;a&quot; &quot;b&quot; &quot;c&quot;</code></pre>
<p><img src="https://d33wubrfki0l68.cloudfront.net/38c47352b8062a6d59318b3bbd1f86b062419322/7780c/diagrams/vectors/data-frame-matrix.png" srcset="/img/loading.gif" style="zoom:33%;" /></p>
</li>
</ul>
<h3 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h3><p><strong>NULL</strong>是特殊的类型，长度（length）为0，不能有任何属性（attributes）</p>
<pre><code><pre><code class="hljs &#123;r&#125;">typeof(NULL)
#&gt; [1] &quot;NULL&quot;

length(NULL)
#&gt; [1] 0

is.null(c())
#&gt; [1] TRUE</code></pre>
</code></pre><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://adv-r.hadley.nz/" target="_blank" rel="noopener">《Advanced R》</a> 学习笔记。
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>[Advanced R] Ⅰ. 控制流</title>
    <url>/2020/08/05/Advanced_R/5.%20Control%20flow/</url>
    <content><![CDATA[<h2 id="Control-flow"><a href="#Control-flow" class="headerlink" title="Control flow"></a>Control flow</h2><h3 id="用if选择"><a href="#用if选择" class="headerlink" title="用if选择"></a>用<code>if</code>选择</h3><ul>
<li><p>对于<code>conditon</code>长度为1的，使用<code>if (condition) true_action else false_action</code>形式来进行选择。其中，<code>conditon</code>可能出现以下情形：</p>
<ul>
<li>为逻辑值（<strong>logical</strong>）：按照<code>TRUE</code>or<code>FALSE</code>来进行选择。</li>
<li>为整数值（<strong>integer</strong>）：如果&gt;0则为<code>TRUE</code>，&lt;0则为<code>FALSE</code>。</li>
<li>为无效输入（<strong>NA</strong>, <strong>character</strong>, …）：返回NA。</li>
</ul>
</li>
<li><p>对于<code>condition</code>为向量的，使用<code>ifelse()</code>来进行选择。当存在多个条件时使用<code>case_when（）</code>进行选择。</p>
<pre><code class="hljs &#123;r&#125;">x &lt;- 1:10
ifelse(x %% 2 &#x3D;&#x3D; 0, &quot;even&quot;, &quot;odd&quot;)
#&gt; [1] &quot;odd&quot;  &quot;even&quot; &quot;odd&quot;  &quot;even&quot; &quot;odd&quot;  &quot;even&quot; &quot;odd&quot;  &quot;even&quot; &quot;odd&quot;  &quot;even&quot;

# 当存在多个条件时,case_when()按顺序进行选择。如果都不匹配，则返回NA。
x &lt;- 1:50
x[runif(10, max &#x3D; 50)] &lt;- NA
case_when(
	is.na(x) ~ &quot;nothing&quot;,
    x %% 7 &#x3D;&#x3D; 0 ~ &quot;Oh yeah!&quot;,
    TRUE ~ as.character(x)
)
#&gt; [1] &quot;1&quot;        &quot;nothing&quot;  &quot;3&quot;        &quot;4&quot;        &quot;5&quot;        &quot;6&quot;        &quot;Oh yeah!&quot; &quot;8&quot;        &quot;nothing&quot; 
#&gt; [10] &quot;10&quot;       &quot;11&quot;       &quot;12&quot;       &quot;13&quot;       &quot;Oh yeah!&quot; &quot;15&quot;       &quot;16&quot;       &quot;17&quot;       &quot;18&quot;      
#&gt; [19] &quot;19&quot;       &quot;20&quot;       &quot;Oh yeah!&quot; &quot;nothing&quot;  &quot;23&quot;       &quot;24&quot;       &quot;25&quot;       &quot;nothing&quot;  &quot;27&quot;      
#&gt; [28] &quot;Oh yeah!&quot; &quot;29&quot;       &quot;nothing&quot;  &quot;31&quot;       &quot;32&quot;       &quot;33&quot;       &quot;34&quot;       &quot;Oh yeah!&quot; &quot;nothing&quot; 
#&gt; [37] &quot;37&quot;       &quot;nothing&quot;  &quot;39&quot;       &quot;40&quot;       &quot;41&quot;       &quot;Oh yeah!&quot; &quot;43&quot;       &quot;44&quot;       &quot;45&quot;      
#&gt; [46] &quot;46&quot;       &quot;nothing&quot;  &quot;48&quot;       &quot;nothing&quot;  &quot;50&quot;</code></pre>
</li>
</ul>
<h3 id="用switch-选择"><a href="#用switch-选择" class="headerlink" title="用switch()选择"></a>用<code>switch()</code>选择</h3><p>使用<code>switch()</code>时需注意在最后包含报错选项，否则未能成果匹配的结果将在不通知的情况下返回<code>NULL</code>。此外，如果<code>switch()</code>中<code>=</code>右方的值为空，那么会自动采用下一个<code>=</code>右方的值</p>
<pre><code class="hljs &#123;r&#125;">option &lt;- function(x)&#123;
    switch(
    	x,
        a &#x3D; &quot;option 1&quot;,
        b &#x3D; &quot;option 2&quot;,
        c &#x3D; &quot;option 3&quot;,
        stop(&quot;Invalid &#96;x&#96; value&quot;)
    )
&#125;

option(&quot;a&quot;)
#&gt; [1] &quot;option 1&quot;

legs &lt;- function(x)&#123;
    switch(
    	x,
        cow &#x3D; ,
        dog &#x3D; 4,
        human &#x3D; 2
    )
&#125;
legs(&quot;cow&quot;)
#&gt; [1] 4</code></pre>
<h3 id="使用循环迭代"><a href="#使用循环迭代" class="headerlink" title="使用循环迭代"></a>使用循环迭代</h3><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a><code>for</code>循环</h4><ul>
<li><p><code>break</code>和<code>next</code>是控制循环的两个重要方式：</p>
<ul>
<li><code>break</code>退出当前整个<code>for</code>循环。</li>
<li><code>next</code>退出当前子循环。</li>
</ul>
<pre><code class="hljs &#123;r&#125;">for (i in 1:10)&#123;
    if (i &lt; 3) &#123;
        next
    &#125;
    print(i)
    if (i &gt;&#x3D; 5) &#123;
        break
    &#125; 
&#125;
#&gt; [1] 3
#&gt; [1] 4
#&gt; [1] 5</code></pre>
</li>
</ul>
<h4 id="for循环常见问题"><a href="#for循环常见问题" class="headerlink" title="for循环常见问题"></a><code>for</code>循环常见问题</h4><p><code>for (item in vector) perform_action</code></p>
<ul>
<li><p>vector长度不能为0</p>
</li>
<li><p>循环可能剥离对象的属性</p>
<pre><code class="hljs &#123;r&#125;">dates &lt;- as.Date(c(&quot;2020-01-01&quot;, &quot;2020-01-02&quot;))
for (i in dates) print(i)
#&gt; [1] 18262
#&gt; [1] 18263

for (i in seq_along(dates)) print(dates[[i]])
#&gt; [1] &quot;2020-01-01&quot;
#&gt; [1] &quot;2020-01-02&quot;</code></pre>
</li>
<li><p>使用<code>list()</code>来储存数据</p>
<pre><code class="hljs &#123;r&#125;">means &lt;- c(1, 10, 20)
out &lt;- vector(&quot;list&quot;, length(means))
for (i in seq_along(means))&#123;
    out[[i]] &lt;- rnorm(10, mean &#x3D; means[[i]])
&#125;</code></pre>
</li>
</ul>
<h4 id="while与repeat循环"><a href="#while与repeat循环" class="headerlink" title="while与repeat循环"></a><code>while</code>与<code>repeat</code>循环</h4><ul>
<li><code>while(condition) action</code>：但<code>condition</code>为真时，执行命令。</li>
<li><code>repeat(action)</code>：不断重复执行命令，知道出现<code>break</code>。</li>
</ul>
<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://adv-r.hadley.nz/" target="_blank" rel="noopener">《Advanced R》</a> 学习笔记。
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>[Advanced R] Ⅰ. 切片</title>
    <url>/2020/08/04/Advanced_R/4.%20Subsetting/</url>
    <content><![CDATA[<h2 id="Subsetting"><a href="#Subsetting" class="headerlink" title="Subsetting"></a>Subsetting</h2><blockquote>
<p>  <strong>切片（Subsetting）是str( )的延续步骤。</strong></p>
</blockquote>
<h3 id="R中的六种切片方式"><a href="#R中的六种切片方式" class="headerlink" title="R中的六种切片方式"></a>R中的六种切片方式</h3><ul>
<li><p>原子向量（atomic vector）中有六种切片方式，本质是通过逻辑值、序号、名字指定出特定元素。</p>
<pre><code class="hljs &#123;r&#125;">x &lt;- c(2, 1, 3, 4)
# positive integers——保留选择
x[order(x)]
#&gt; [1] 1 2 3 4
x[c(2.1, 2.2, 2.3, 2.6, 2.7, 2.8)] #R自动向下取整
#&gt; [1] 1 1 1 1 1 1

# negative integers——删去选择
x[-c(3, 1)]
#&gt; [1] 1 4

# logical vectors
x[c(T, T, F, T)]
#&gt; [1] 2 1 4
x[c(T, T, F)] #缺失的默认为TRUE
#&gt; [1] 2 1 4
x[c(T, F)] #长度不够自动循环
#&gt; [1] 2 3

# Nothing——返回原向量
x[]
#&gt; [1] 2 1 3 4

# zero——返回长度为0的向量
x[0]
#&gt; numeric(0)

# character vectors——如果原向量含有名字，那么通过选择名字来筛选</code></pre>
</li>
<li><p><strong>列表（list）</strong>的切片方式与原子向量相似，使用<code>[ ]</code>来返回list；使用<code>[[ ]]</code>*和<code>$</code>来返回数值。</p>
</li>
<li><p>在处理多维结构的向量（如矩阵、数据框）时，可以选择三种方式来切片：</p>
<ul>
<li><p>多维向量：分别选定行、列</p>
</li>
<li><p>单一向量：由于多为结构本质上是向量，因而可以使用单一向量的方式来按顺序切片。</p>
<pre><code class="hljs &#123;r&#125;">vals &lt;- outer(1:5, 1:5, FUN &#x3D; &quot;paste&quot;, sep &#x3D; &quot;,&quot;)
vals
#&gt;      [,1]  [,2]  [,3]  [,4]  [,5] 
#&gt; [1,] &quot;1,1&quot; &quot;1,2&quot; &quot;1,3&quot; &quot;1,4&quot; &quot;1,5&quot;
#&gt; [2,] &quot;2,1&quot; &quot;2,2&quot; &quot;2,3&quot; &quot;2,4&quot; &quot;2,5&quot;
#&gt; [3,] &quot;3,1&quot; &quot;3,2&quot; &quot;3,3&quot; &quot;3,4&quot; &quot;3,5&quot;
#&gt; [4,] &quot;4,1&quot; &quot;4,2&quot; &quot;4,3&quot; &quot;4,4&quot; &quot;4,5&quot;
#&gt; [5,] &quot;5,1&quot; &quot;5,2&quot; &quot;5,3&quot; &quot;5,4&quot; &quot;5,5&quot;

vals[c(1, 4, 15)] #从第一列开始顺序筛选
[1] &quot;1,1&quot; &quot;4,1&quot; &quot;5,3&quot;</code></pre>
</li>
<li><p>矩阵（matrix）：使用<strong>2-column矩阵来筛选矩阵</strong>；使用<strong>3-column矩阵来筛选数组</strong>。</p>
<pre><code class="hljs &#123;r&#125;">select &lt;- matrix(ncol &#x3D; 2, byrow &#x3D; TRUE, c(
  1, 1,
  3, 1,
  2, 4
))
vals[select] #行、列分别用来指定特定位置
#&gt; [1] &quot;1,1&quot; &quot;3,1&quot; &quot;2,4&quot;</code></pre>
</li>
</ul>
</li>
<li><p><strong>Data.Frame</strong>同时具有list和matrix两方面特征</p>
<ul>
<li><p>输入单一参数时，<strong>Data.Frame</strong>表现得像lists，输入的参数<strong>对列进行切片</strong>。</p>
</li>
<li><p>输入两个参数时，<strong>Data.Frame</strong>表现得像matrices。但注意data.frame如下的细节，相对地，tibbles总是返回tibbles。<strong>这是因为在对data.frame或其它matrices进行切片时，R总是会返回降维后的值（除非使用<code>drop = FALSE</code>）</strong>。对此，tibbles默认了<code>drop = FALSE</code>。</p>
<pre><code class="hljs &#123;r&#125;">df &lt;- data.frame(x &#x3D; 1:3, y &#x3D; 3:1, z &#x3D; letters[1:3])
df[&quot;x&quot;]
#&gt;   x
#&gt; 1 1
#&gt; 2 2
#&gt; 3 3
df[,&quot;x&quot;]
#&gt; [1] 1 2 3</code></pre>
</li>
</ul>
</li>
<li><p><strong>因子向量（Factor）</strong>在进行切片时，如果不使用<code>drop = FALSE</code>，因子的level可能被遗弃。</p>
<pre><code class="hljs &#123;r&#125;">z &lt;- factor(c(&quot;a&quot;, &quot;b&quot;))
z[1]
#&gt; [1] a
#&gt; Levels: a b
z[1, drop &#x3D; TRUE]
#&gt; [1] a
#&gt; Levels: a</code></pre>
</li>
</ul>
<h3 id="选择特定变量"><a href="#选择特定变量" class="headerlink" title="选择特定变量"></a>选择特定变量</h3><p>使用<code>[[ ]]</code> 与<script type="math/tex">`来选择特定变量（`</script>是<code>[[ ]]</code>的简写），效果相似，但存在如下区别：</p>
<ul>
<li><p><code>$</code>和<code>[[</code>在呼叫用另一个对象存储的变量时可能存在区别：<code>x$y</code>将被翻译为<code>x[[“y”]]</code></p>
<pre><code class="hljs &#123;r&#125;">var &lt;- &quot;cyl&quot;
mtcars$var
#&gt; NULL
mtcars[[var]]
#&gt; [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4</code></pre>
</li>
<li><p><code>$</code>可以适用于部分匹配，而<code>[[</code>不行。</p>
</li>
</ul>
<h3 id="切片与赋值"><a href="#切片与赋值" class="headerlink" title="切片与赋值"></a>切片与赋值</h3><p><code>x[i] &lt;- value</code>是切片赋值的基本形式</p>
<ul>
<li><p>使用<code>x[ ]</code>空白切片来赋值具有一些特殊用法：</p>
<pre><code class="hljs &#123;r&#125;">mtcars &lt;- lapply(mtcars, as.integer) # 按column对对象使用函数
is.data.frame(mtcars)
#&gt; [1] TRUE

mtcars &lt;- lapply(mtcars, as.integer) # 相当于新赋予了一个变量
is.data.frame(mtcars)
#&gt; [1] FALSE</code></pre>
</li>
</ul>
<h3 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h3><h4 id="查询表格"><a href="#查询表格" class="headerlink" title="查询表格"></a>查询表格</h4><p>通过「字符串匹配」的方式，制作索引向量来替换变量：①字符串匹配；②<strong>[ ]</strong>查询是无限次的。</p>
<pre><code class="hljs &#123;r&#125;">x &lt;- c(&quot;m&quot;, &quot;f&quot;, &quot;u&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;, &quot;m&quot;)
lookup &lt;- c(m &#x3D; &quot;Male&quot;, f &#x3D; &quot;Female&quot;, u &#x3D; NA)
lookup
#&gt;        m        f        u 
#&gt;   &quot;Male&quot; &quot;Female&quot;       NA

lookup[x]
#&gt;        m        f        u        f        f        m        m 
#&gt;   &quot;Male&quot; &quot;Female&quot;       NA &quot;Female&quot; &quot;Female&quot;   &quot;Male&quot;   &quot;Male&quot;</code></pre>
<h4 id="通过匹配合并"><a href="#通过匹配合并" class="headerlink" title="通过匹配合并"></a>通过匹配合并</h4><p>制作信息表来方向匹配。</p>
<pre><code class="hljs &#123;r&#125;"># 数据
grades &lt;- c(1, 2, 2, 3, 2, 2, 1, 3, 1)

info_table &lt;- data.frame(
	grade &#x3D; 3:1,
    desc &#x3D; c(&quot;Excellent&quot;, &quot;Good&quot;, &quot;Poor&quot;),
    fail &#x3D; c(F, F, T)
)

# 匹配
id &lt;- match(grades, info_table$grade)
id 
#&gt; [1] 3 2 2 1 2 2 3 1 3
info_table[id,]
#&gt;   grade desc      fail 
#&gt;   &lt;int&gt; &lt;chr&gt;     &lt;lgl&gt;
#&gt; 1     1 Poor      TRUE 
#&gt; 2     2 Good      FALSE
#&gt; 3     2 Good      FALSE
#&gt; 4     3 Excellent FALSE
#&gt; 5     2 Good      FALSE
#&gt; 6     2 Good      FALSE
#&gt; 7     1 Poor      TRUE 
#&gt; 8     3 Excellent FALSE
#&gt; 9     1 Poor      TRUE</code></pre>
<h4 id="随机样本"><a href="#随机样本" class="headerlink" title="随机样本"></a>随机样本</h4><p>使用<code>sample(n)</code>来对矩阵、数据框随机切片（<code>df[sample()]</code>）。</p>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>使用<code>c(1, 2, 3, …)</code>，通过<code>[[ ]]</code>来对数据框重新排序。</p>
<h4 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h4><p>将选出的对象设置为<code>NULL</code>来移除特定变量，或者保留想要的。</p>
<pre><code class="hljs &#123;r&#125;">df &lt;- data.frame(x &#x3D; 1:3, y &#x3D; 3:1, z &#x3D; letters[1:3])
df[setdiff(names(df), &quot;z&quot;)]
#&gt;   x y
#&gt; 1 1 3
#&gt; 2 2 2
#&gt; 3 3 1</code></pre>
<h4 id="结合逻辑值"><a href="#结合逻辑值" class="headerlink" title="结合逻辑值"></a>结合逻辑值</h4><p>注意逻辑值和数值之间的转换，主要差别在于存在缺失值（<code>NA</code>）时：</p>
<ul>
<li><code>c[which(x)]</code>会在遇到<code>NA</code>时，直接遗弃对应值。</li>
<li><code>c[x]</code>会在遇到<code>NA</code>时，返回<code>NA</code>。</li>
</ul>
<pre><code class="hljs &#123;r&#125;">c &lt;- c(1:10)

# 设置切片条件
(x &lt;- sample(10) &lt; 4)
#&gt; [1] FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE
which(x) #将逻辑值转换为数值
#&gt; [1]  6  9 10

# 切片
(c[which(x)])
#&gt; [1] 3 6 9
(c[x])
#&gt; [1] 3 6 9</code></pre>
<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://adv-r.hadley.nz/" target="_blank" rel="noopener">《Advanced R》</a> 学习笔记。
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>[Advanced R] Ⅰ. 函数</title>
    <url>/2020/08/06/Advanced_R/6.%20Functions/</url>
    <content><![CDATA[<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><blockquote>
<p>  <strong>存在即对象，万物出自函数</strong>。</p>
</blockquote>
<h3 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h3><h4 id="函数构成三要素"><a href="#函数构成三要素" class="headerlink" title="函数构成三要素"></a>函数构成三要素</h4><p>函数的拥有三个基本组成：参数（arguments）、主体（body）和环境（environment），分别使用<code>formals()</code>、<code>body()</code>和<code>environment()</code>来查看。</p>
<pre><code class="hljs &#123;r&#125;">fun0 &lt;- function(x, y) x+y
formals(fun0)
#&gt; $x

#&gt; $y
body(fun0)
#&gt; x+y

environment(fun0)
#&gt; &lt;environment: R_GlobalEnv&gt;</code></pre>
<h4 id="初始函数的特殊性"><a href="#初始函数的特殊性" class="headerlink" title="初始函数的特殊性"></a>初始函数的特殊性</h4><p>R中包含了大量由C语言编写的初始函数（primitive functions），其在R中的属性要么为<code>builtin</code>和<code>special</code>，其不具备一般函数中的三大要素。</p>
<pre><code class="hljs &#123;r&#125;">typeof(sum)
#&gt; [1] &quot;builtin&quot;
typeof(&#96;[&#96;)
#&gt; [1] &quot;special&quot;</code></pre>
<h4 id="函数也是对象"><a href="#函数也是对象" class="headerlink" title="函数也是对象"></a>函数也是对象</h4><ul>
<li><p>名称和函数对象（function object）也是链接（binding）的关系。同时，函数对象不一定需要名称，可以使用匿名函数（anonymous function）。例如在<code>lapply(X, FUN)</code>中编写的函数。</p>
</li>
<li><p>函数也可以像其它对象一样被放入list中。</p>
<pre><code class="hljs &#123;r&#125;">funs &lt;- list(
	half &#x3D; function(x) x&#x2F;2,
    double &#x3D; function(x) x*2
)
funs$half(3)
#&gt; [1] 1.5</code></pre>
</li>
</ul>
<h4 id="使用do-call"><a href="#使用do-call" class="headerlink" title="使用do.call()"></a>使用<code>do.call()</code></h4><p>当函数名与参数分离时，使用<code>do.call（FUN，args）</code>来呼叫函数。</p>
<pre><code class="hljs &#123;r&#125;">args &lt;- list(runif(100), na.rm &#x3D; TRUE)
do.call(sum, args)
#&gt; [1] 55.449</code></pre>
<h3 id="词法范围（Lexical-Scoping）"><a href="#词法范围（Lexical-Scoping）" class="headerlink" title="词法范围（Lexical Scoping）"></a>词法范围（Lexical Scoping）</h3><p>词法范围解释了R中的函数如何识别对象值（value）和名称（name）间的链接，其遵从四个基本法则：</p>
<ul>
<li>Name masking：函数内<strong>定义的对象名</strong>将覆盖函数外定义的。</li>
<li>Functions VS Variables：函数内<strong>定义的函数</strong>也将覆盖函数外定义的。</li>
<li>A fresh start：函数内运行结果不会影响全局中的对象。</li>
<li>Dynamic lookup：函数每次运行时即时查找所需对象。</li>
</ul>
<h3 id="惰性评估"><a href="#惰性评估" class="headerlink" title="惰性评估"></a>惰性评估</h3><h4 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h4><p>R只会在需要用到参数时，检测其是否为有效参数。由于惰性评估（lazy evaluation），R的函数需要以下要素：</p>
<ul>
<li><p>含有参数的表达式</p>
</li>
<li><p>用以评估（监测有效性）参数的的环境。</p>
<ul>
<li>在呼叫函数时定义的对象，将反映到全局环境中。注意：只对使用<code>&lt;-</code>方式定义的有效，<code>=</code>定义的不行。</li>
</ul>
<pre><code class="hljs &#123;r&#125;"># 在呼叫函数时定义的对象，将反映到全局环境中
fun1 &lt;- function(x) x+2
fun1(x &lt;- 2)
#&gt; [1] 4</code></pre>
</li>
<li><p>参数值</p>
</li>
</ul>
<h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><ul>
<li><p>默认参数可直接给出，或者由其它参数给出，乃至由函数中定义的对象给出。</p>
</li>
<li><p>默认参数存在与函数的评估环境（evaluation environment）中，而非全局环境（global environment）。</p>
<pre><code class="hljs &#123;r&#125;">fun &lt;- function(x &#x3D; ls()) &#123;
    a &lt;- 1
    x
&#125;
fun()
#&gt; [1] &quot;a&quot; &quot;x&quot;

fun(ls())
#&gt; [1] &quot;fun&quot;</code></pre>
</li>
<li><p>使用<code>missing()</code>来判断参数值是否由默认给出。</p>
</li>
</ul>
<h3 id="…（dot-dot-dot）"><a href="#…（dot-dot-dot）" class="headerlink" title="…（dot-dot-dot）"></a>…（dot-dot-dot）</h3><p>使用<code>...</code>来为函数添加更多的参数。</p>
<ul>
<li><p>使用<code>..n</code>来提取特定位置的参数</p>
<pre><code class="hljs &#123;r&#125;">fun &lt;- function(...) list(first &#x3D; ..1, third &#x3D; ..4)
fun(1,2,3,4)
#&gt; $first
#&gt; [1] 1

#&gt; $third
#&gt; [1] 4</code></pre>
</li>
<li><p>直接使用<code>list(...)</code>来将输入的参数储存为列表</p>
<pre><code class="hljs &#123;r&#125;">fun &lt;- function(...) list(...)
fun(a &#x3D; 1, b &#x3D; 2)
#&gt; $a
#&gt; [1] 1

#&gt; $b
#&gt; [1] 2</code></pre>
</li>
</ul>
<h3 id="退出函数"><a href="#退出函数" class="headerlink" title="退出函数"></a>退出函数</h3><h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><ul>
<li>隐性返回（implicit return）：最后被执行的表达式即为返回的值</li>
<li>显性返回（explicit return）：使用<code>return()</code></li>
</ul>
<h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><p>使用<code>stop()</code>来立即停止当前函数。</p>
<h4 id="隐藏返回值"><a href="#隐藏返回值" class="headerlink" title="隐藏返回值"></a>隐藏返回值</h4><p>使用<code>invisible()</code>来将返回值隐藏。</p>
<pre><code class="hljs &#123;r&#125;">fun &lt;- function(x) invisible(x)
fun(232)</code></pre>
<h4 id="退出窗口"><a href="#退出窗口" class="headerlink" title="退出窗口"></a>退出窗口</h4><p>使用<code>on.exit(, add = TRUE)</code>来作为函数的退出窗口（exit handler），用以确保不论函数如何退出，都不会改变全局环境。</p>
<ul>
<li><p><code>on.exit()</code>不论函数正常执行、报错都将执行。</p>
<pre><code class="hljs &#123;r&#125;">fun &lt;- function(x)&#123;
    cat(&quot;Let&#39;s start.\n&quot;)
    on.exit(cat(&quot;This is a exit handler.\n&quot;), add &#x3D; TRUE)
    
    if (x) &#123;
        return(10)
    &#125; else&#123;
        stop(&quot;Error&quot;)
    &#125;
&#125;
fun(TRUE)
#&gt; Let&#39;s start
#&gt; This is a exit handler
#&gt; [1] 10

fun(FALSE)</code></pre>
</li>
</ul>
<h3 id="函数形态"><a href="#函数形态" class="headerlink" title="函数形态"></a>函数形态</h3><h4 id="四种存在形态"><a href="#四种存在形态" class="headerlink" title="四种存在形态"></a>四种存在形态</h4><p>R中函数有四种不同的存在形态，各形态之间在一定程度上可相互转换：</p>
<ul>
<li>prefix：普通函数，<code>FUN(x, y, z)</code></li>
<li>infix：在参数中出现的函数，<code>+</code>、<code>%&gt;%</code></li>
<li>replacement：通过赋值存在的函数，<code>&lt;-</code></li>
<li>special：<code>[[]]</code>、<code>if</code>、<code>for</code></li>
</ul>
<h4 id="函数形态变换"><a href="#函数形态变换" class="headerlink" title="函数形态变换"></a>函数形态变换</h4><ul>
<li><p>转换为前置形态</p>
<pre><code class="hljs &#123;r&#125;">x + y
&#96;+&#96;(x, y)

names(df) &lt;- c(x, y, z)
&#96;names&lt;-&#96;（df, c(x, y, z）)

for (i in 1:10) print(i)
&#96;for&#96;(i, 1:10, print(i))</code></pre>
</li>
<li><p>改写每个non-prefix形态的函数</p>
<pre><code class="hljs &#123;r&#125;">&#96;+&#96; &lt;- function(e1, e2)&#123;
    x &lt;- runif(1)
    if (x &lt; 0.5)&#123;
        e1 - e2
    &#125; else&#123;
        sum(e1, e2)
    &#125;
&#125;

replicate(100, 1+2)
#&gt; [1] -1  3 -1 -1 -1  3 -1 -1 -1  3 -1 -1 -1  3 -1  3  3  3  3 -1  3 -1  3  3  3  3 -1 -1 -1  3 -1 -1  3  3
#&gt; [35]  3  3  3  3  3  3 -1  3 -1 -1  3  3  3 -1  3 -1 -1 -1  3  3 -1  3 -1 -1 -1 -1 -1 -1  3  3 -1 -1 -1  3
#&gt; [69] -1 -1 -1 -1  3  3  3  3 -1 -1 -1  3 -1 -1  3  3  3 -1  3 -1 -1 -1 -1 -1 -1 -1  3 -1  3 -1  3 -1

replicate(100, (1+2)) #添加括号后又回归原有的定义，&quot;(&quot;本身也是一个函数
#&gt; [1] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
#&gt; [52] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3</code></pre>
</li>
</ul>
<h4 id="自定义infix函数"><a href="#自定义infix函数" class="headerlink" title="自定义infix函数"></a>自定义infix函数</h4><p>使用<code>%</code>来自定义infix函数</p>
<pre><code class="hljs &#123;r&#125;">&#96;%+%&#96; &lt;- function(a, b)&#123;
    paste0(a, b)
&#125;

4 %+% 4
#&gt; [1] &quot;44&quot;</code></pre>
<h4 id="替换函数"><a href="#替换函数" class="headerlink" title="替换函数"></a>替换函数</h4><p>替换函数（replacement function）将右边的值输入左边函数中，需要有两个必要要素：</p>
<ul>
<li>参数x用以储存值，参数value用以替换值。</li>
<li>函数主体中需要返回替换后的值。</li>
</ul>
<pre><code class="hljs &#123;r&#125;">&#96;replace_2nd&lt;-&#96; &lt;- function(x, value)&#123;
    x[2] &lt;- value
    x
&#125; 

c&lt;- 1:10
replace_2nd(c) &lt;- 101L
c
#&gt; [1]   1 101   3   4   5   6   7   8   9  10</code></pre>
<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://adv-r.hadley.nz/" target="_blank" rel="noopener">《Advanced R》</a> 学习笔记。
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>[Advanced R] Ⅰ.环境</title>
    <url>/2020/08/07/Advanced_R/7.%20Environment/</url>
    <content><![CDATA[<h2 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h2><blockquote>
<p>  <strong>存在即对象，万物出自函数</strong>。</p>
</blockquote>
<h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>环境中的变量需要有一下特征：</p>
<ul>
<li>独立的名称</li>
<li>环境中的变量名没有顺序：使用<code>env_names()</code>来获取变量名，<code>env_print()</code>来获取详细变量名。</li>
<li>除空环境外（empty environment），所有环境都有父环境（parent）：使用<code>env_parent()</code>来获取父环境。当子环境没有所查找变量时，R便在父环境中寻找。</li>
<li>环境在被修改时不会被复制，而是立即修改。</li>
</ul>
<p>使用<code>rlang::env()</code>来创造一个环境</p>
<h3 id="在环境间循环"><a href="#在环境间循环" class="headerlink" title="在环境间循环"></a>在环境间循环</h3><p>由于每个环境都存在父环境，同时R中的函数词义范围允许lazy evaluation，可以编写函数来实现环境间的循环：</p>
<pre><code class="hljs &#123;r&#125;">library(rlang)

where &lt;- function(name, env &#x3D; caller_env())&#123;
    if (identical(env, empty_env()))&#123;
        stop(&quot;Can&#39;t find &quot;, name, call. &#x3D; FALSE)
    &#125; else if (env_has(env, name)) &#123;
        env
    &#125; else &#123;
        where(name, env_parent(env))
    &#125;
&#125;

where(&quot;a&quot;)
#&gt; &lt;environment: R_GlobalEnv&gt;
where(&quot;sum&quot;)
#&gt; &lt;environment: base&gt;
where(&quot;+&quot;)
#&gt; &lt;environment: base&gt;</code></pre>
<h3 id="特殊环境"><a href="#特殊环境" class="headerlink" title="特殊环境"></a>特殊环境</h3><h4 id="Package环境"><a href="#Package环境" class="headerlink" title="Package环境."></a>Package环境.</h4><p>每个新被加载的包都成为<code>R_GlobalEnv</code>的父环境，可以使用<code>search()</code>来查看被加载的环境名，使用<code>search_envs()</code>来查看被加载的环境。</p>
<p><img src="https://d33wubrfki0l68.cloudfront.net/038b2da4f5db1d2a8acaf4ee1e7d08d04ab36ebc/ac22a/diagrams/environments/search-path.png" srcset="/img/loading.gif" style="zoom:33%;" /></p>
<pre><code class="hljs &#123;r&#125;">search_envs()
#&gt; [[1]] $ &lt;env: global&gt;
#&gt; [[2]] $ &lt;env: package:rlang&gt;
#&gt; [[3]] $ &lt;env: tools:rstudio&gt;
#&gt; [[4]] $ &lt;env: package:stats&gt;
#&gt; [[5]] $ &lt;env: package:graphics&gt;
#&gt; [[6]] $ &lt;env: package:grDevices&gt;
#&gt; [[7]] $ &lt;env: package:utils&gt;
#&gt; [[8]] $ &lt;env: package:datasets&gt;
#&gt; [[9]] $ &lt;env: package:methods&gt;
#&gt; [[10]] $ &lt;env: Autoloads&gt;
#&gt; [[11]] $ &lt;env: package:base&gt;</code></pre>
<h4 id="函数环境"><a href="#函数环境" class="headerlink" title="函数环境"></a>函数环境</h4><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://adv-r.hadley.nz/" target="_blank" rel="noopener">《Advanced R》</a> 学习笔记。
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>[Advanced R] Ⅱ.泛函数（1）</title>
    <url>/2020/08/13/Advanced_R/9.%20Functionals/</url>
    <content><![CDATA[<h2 id="Functionals"><a href="#Functionals" class="headerlink" title="Functionals"></a>Functionals</h2><blockquote>
<p>  泛函数以函数为输入，返回向量作为输出。</p>
</blockquote>
<h3 id="purrr-map-函数"><a href="#purrr-map-函数" class="headerlink" title="purrr::map()函数"></a><code>purrr::map()</code>函数</h3><h4 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h4><p><code>map(.x, .f, ...)</code></p>
<ul>
<li><code>.x</code>为输入的向量，<strong>是输入函数的第一个参数</strong>；<code>.f</code>为应用函数，<code>...</code>输入函数的参数。</li>
<li>通过<code>map_*()</code>来控制输出结果表现形式。</li>
</ul>
<h4 id="匿名函数与快捷方式"><a href="#匿名函数与快捷方式" class="headerlink" title="匿名函数与快捷方式"></a>匿名函数与快捷方式</h4><p><code>purrr</code>为匿名函数提供了多种快捷方式</p>
<ul>
<li><p>标准形式</p>
<pre><code class="hljs &#123;r&#125;">map_dbl(mtcars, function(x) length(unique(x)))</code></pre>
</li>
<li><p>快捷方式：<code>purrr</code>将由<code>~</code>开头的表达式转换为函数，<strong>并允许</strong>将<code>.</code>开头的字符理解为参数。其中，<code>.x</code>和<code>.y</code>分别表示第一、第二个参数，或者使用<code>..1</code>、<code>..2</code>、<code>..3</code>来表示序号不同的参数。</p>
<pre><code class="hljs &#123;r&#125;">map_dbl(mtcars, ~length(unique(.x)))

# 不需要参数的匿名函数
map_dbl(1:3, ~sample(1:10, 1))
#&gt; [1] 5 2 1</code></pre>
</li>
</ul>
<h4 id="提取元素"><a href="#提取元素" class="headerlink" title="提取元素"></a>提取元素</h4><p>使用<code>map()</code>函数提取特定元素，如果不满足要求，则将返回错误（可使用<code>.default = NA</code>避免）。</p>
<pre><code class="hljs &#123;r&#125;">x &lt;- list(
  list(-1, x &#x3D; 1, y &#x3D; c(2), z &#x3D; &quot;a&quot;),
  list(-2, x &#x3D; 4, y &#x3D; c(5, 6), z &#x3D; &quot;b&quot;),
  list(-3, x &#x3D; 8, y &#x3D; c(9, 10, 11))
)

# 使用名称提取
map_dbl(x, &quot;x&quot;)
#&gt; [1] 1 4 8

# 使用序号提取
map_dbl(x, 1)
#&gt; [1] -1 -2 -3

# 同时使用二者
map_dbl(x, list(&quot;y&quot;, 1))
#&gt; [1] 2 5 9</code></pre>
<h4 id="使用-向函数传递参数"><a href="#使用-向函数传递参数" class="headerlink" title="使用...向函数传递参数"></a>使用<code>...</code>向函数传递参数</h4><ul>
<li><p><code>...</code>内的参数将以向量形式在各个细分类别中循环：<img src="https://d33wubrfki0l68.cloudfront.net/a468c847ea8aca9a6131492e1e7431f418259eaf/ce4e0/diagrams/functionals/map-arg-recycle.png" srcset="/img/loading.gif" style="zoom:33%;" /></p>
</li>
<li><p><code>...</code>内的参数在每次执行<code>map()</code>时即确定</p>
<pre><code class="hljs &#123;r&#125;">x &lt;- c(0, 0, 0, 0)
map_dbl(x, ~.x + .y, runif(1))
#&gt; [1] 0.4003342 0.4003342 0.4003342 0.4003342
plus &lt;- function(x, y) x+y
map_dbl(x, ~plus(.x, y &#x3D; runif(1)))
#&gt; [1] 0.47520775 0.01718815 0.37455781 0.44909849</code></pre>
</li>
</ul>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>为函数应用可变的参数（使蓝色的框变动不同）<img src="https://d33wubrfki0l68.cloudfront.net/6d0b927ba5266f886cc721ae090afcc5e872a748/f8636/diagrams/functionals/map-arg-flipped.png" srcset="/img/loading.gif" style="zoom:33%;" /></p>
<ul>
<li><p>将可变参数作为第一个参数（<code>.x</code>）输入。</p>
</li>
<li><p>使用R函数的灵活匹配。</p>
<pre><code class="hljs &#123;r&#125;">trims &lt;- c(0, 0.1, 0.2, 0.5)
x &lt;- runif(100)
map_dbl(trims, ~mean(x, trim &#x3D; .x))
#&gt; [1] 0.4776990 0.4710686 0.4596495 0.4486498
map_dbl(trims, mean, x &#x3D; x)
#&gt; [1] 0.4776990 0.4710686 0.4596495 0.4486498</code></pre>
</li>
</ul>
<h3 id="purrr工作流程"><a href="#purrr工作流程" class="headerlink" title="purrr工作流程"></a><code>purrr</code>工作流程</h3><p>对处理对象进行分组，并使用<code>map()</code>配合函数进行每一步处理。</p>
<pre><code class="hljs &#123;r&#125;">by_cyl &lt;- split(mtcars, mtcars$cyl)

by_cyl %&gt;% 
  map(~ lm(mpg ~ wt, data &#x3D; .x)) %&gt;% 
  map(coef) %&gt;% 
  map_dbl(2)
#&gt;     4     6     8 
#&gt; -5.65 -2.78 -2.19</code></pre>
<h3 id="map族函数"><a href="#map族函数" class="headerlink" title="map族函数"></a>map族函数</h3><p>除基础的<code>map()</code>外，map族函数还包含以下几类：</p>
<ul>
<li>输入与输出相同格式：<code>modify()</code></li>
<li>对两个输入参数循环：<code>map2()</code></li>
<li>对输入参数及其序号循环：<code>imap()</code></li>
<li>不输出结果：<code>walk()</code></li>
<li>对任意数量输入参数循环：<code>pmap()</code></li>
</ul>
<p>针对不同的输入、输出情况，以上的map族函数也有其对应的形式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">List</th>
<th style="text-align:center">Atomic</th>
<th style="text-align:center">Same type</th>
<th style="text-align:center">Nothing</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">One argument</td>
<td style="text-align:center"><code>map()</code></td>
<td style="text-align:center"><code>map_lgl()</code>, …</td>
<td style="text-align:center"><code>modify()</code></td>
<td style="text-align:center"><code>walk()</code></td>
</tr>
<tr>
<td style="text-align:center">Two arguments</td>
<td style="text-align:center"><code>map2()</code></td>
<td style="text-align:center"><code>map2_lgl()</code>, …</td>
<td style="text-align:center"><code>modify2()</code></td>
<td style="text-align:center"><code>walk2()</code></td>
</tr>
<tr>
<td style="text-align:center">One argument + index</td>
<td style="text-align:center"><code>imap()</code></td>
<td style="text-align:center"><code>imap_lgl()</code>, …</td>
<td style="text-align:center"><code>imodify()</code></td>
<td style="text-align:center"><code>iwalk()</code></td>
</tr>
<tr>
<td style="text-align:center">N arguments</td>
<td style="text-align:center"><code>pmap()</code></td>
<td style="text-align:center"><code>pmap_lgl()</code>, …</td>
<td style="text-align:center">-</td>
<td style="text-align:center"><code>pwalk()</code></td>
</tr>
</tbody>
</table>
</div>
<h4 id="modify"><a href="#modify" class="headerlink" title="modify()"></a><code>modify()</code></h4><p><code>modify()</code>可以输出与输入相同格式的对象，但其并不是「立即修改」的。</p>
<pre><code class="hljs &#123;r&#125;">df &lt;- data.frame(x &#x3D; 1:3, y &#x3D; 6:4)

map(df, ~.x * 2)
#&gt; $x
#&gt; [1] 2 4 6

#&gt; $y
#&gt; [1] 12 10  8
modify(df, ~.x * 2)
#&gt;   x  y
#&gt; 1 2 12
#&gt; 2 4 10
#&gt; 3 6  8</code></pre>
<h4 id="map2"><a href="#map2" class="headerlink" title="map2()"></a><code>map2()</code></h4><ul>
<li><p>使用<code>map()</code>来输入两个参数无法处理第二个参数为向量的情况：<img src="https://d33wubrfki0l68.cloudfront.net/a468c847ea8aca9a6131492e1e7431f418259eaf/ce4e0/diagrams/functionals/map-arg-recycle.png" srcset="/img/loading.gif" style="zoom:33%;" /></p>
</li>
<li><p>使用<code>map2()</code>来提供两个次序不同，但相同地位的输入：<img src="https://d33wubrfki0l68.cloudfront.net/f5cddf51ec9c243a7c13732b0ce46b0868bf8a31/501a8/diagrams/functionals/map2.png" srcset="/img/loading.gif" style="zoom:33%;" /></p>
<pre><code class="hljs &#123;r&#125;">value &lt;- map(1:5, ~runif(10))
value[[1]][[1]] &lt;- NA

weight &lt;- map(1:5, ~runif(10))

map2_dbl(value, weight, weighted.mean)
#&gt; [1]        NA 0.4119934 0.4984402 0.3880366 0.5391378
map2_dbl(value, weight, weighted.mean, na.rm &#x3D; T)
#&gt; [1] 0.6927842 0.4119934 0.4984402 0.3880366 0.5391378</code></pre>
</li>
<li><p><code>map2()</code>函数的会自动循环长度较短的输入以确保两个输入具有相同的长度，即将<code>map2(x, y, f)</code>转换为<code>map(x, f, y)</code>：<img src="https://d33wubrfki0l68.cloudfront.net/55032525ec77409e381dcd200a47e1787e65b964/dcaef/diagrams/functionals/map2-recycle.png" srcset="/img/loading.gif" style="zoom:33%;" /></p>
</li>
</ul>
<h4 id="walk"><a href="#walk" class="headerlink" title="walk()"></a><code>walk()</code></h4><p>使用<code>walk()</code>来实现一些循环的副作用，但不输出特定结果。</p>
<pre><code class="hljs &#123;r&#125;">temp &lt;- tempfile()
dir.create(temp)

cyls &lt;- split(mtcars, mtcars$cyl)
paths &lt;- file.path(temp, paste0(&quot;cyl-&quot;, names(cyls), &quot;.csv&quot;))
walk2(cyls, paths, write.csv)

dir(temp)
#&gt; [1] &quot;cyl-4.csv&quot; &quot;cyl-6.csv&quot; &quot;cyl-8.csv&quot;</code></pre>
<h4 id="imap"><a href="#imap" class="headerlink" title="imap()"></a><code>imap()</code></h4><p>在读取输入的参数时，同时读取参数的名称及序号。<code>imap(x, f)</code>等价于<code>map2(x, names(x), f)</code>或<code>map2(x, seq_along(x), f)</code></p>
<h4 id="pmap"><a href="#pmap" class="headerlink" title="pmap()"></a><code>pmap()</code></h4><ul>
<li><p>通过输入一个带有多个参数的<strong>list</strong>来进行输入：<img src="https://d33wubrfki0l68.cloudfront.net/e426c5755e2e65bdcc073d387775db79791f32fd/92902/diagrams/functionals/pmap.png" srcset="/img/loading.gif" style="zoom:33%;" /></p>
<pre><code class="hljs &#123;r&#125;">pmap_dbl(list(value, weight), weighted.mean)
#&gt; [1]        NA 0.4119934 0.4984402 0.3880366 0.5391378</code></pre>
</li>
<li><p><code>pmap()</code>能够对参数名称进行定义</p>
<pre><code class="hljs &#123;r&#125;">trims &lt;- c(0, 0.1, 0.2, 0.5)
x &lt;- runif(100)

pmap_dbl(list(trim &#x3D; trims), mean, x &#x3D; x)
#&gt; [1]        NA 0.4119934 0.4984402 0.3880366 0.5391378</code></pre>
</li>
<li><p><code>pmap()</code>在数据框中的应用，把每行作为单独的函数进行循环：<img src="https://d33wubrfki0l68.cloudfront.net/e698354d802ce16f83546db63c45a19b8d51f45e/43de7/diagrams/functionals/pmap-3.png" srcset="/img/loading.gif" style="zoom:33%;" /></p>
</li>
</ul>
<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://adv-r.hadley.nz/" target="_blank" rel="noopener">《Advanced R》</a> 学习笔记。
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>[CFA-1] 投资组合</title>
    <url>/2020/02/29/CFA/Portfolio_Management/</url>
    <content><![CDATA[<h2 id="Portfolio-Management"><a href="#Portfolio-Management" class="headerlink" title="Portfolio Management"></a>Portfolio Management</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><strong>「投资组合的好处：一定条件下，多元化有助于降低整体风险」</strong></p>
<h5 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h5><ul>
<li><p>组合视角（portfolio perspective）</p>
<p>  组合视角：通过一只股票对整个组合<strong>收益</strong>、<strong>风险</strong>的影响来对其评估。</p>
</li>
<li><p>多元化的价值（risk-reduction benefits of diversification）</p>
<p> <strong>在资产不是绝对正相关的情况下</strong>，多元化有助于降低资产组合的风险。<strong>随着相关性增加</strong>，多元化带来的收益将下降。</p>
<blockquote>
<p>  多元化比率（diversification ratio）：$R_{p}/R_i$</p>
<ul>
<li>度量多元化带来的风险减少收益。</li>
</ul>
</blockquote>
</li>
<li><p>组合管理步骤（portfolio management process）</p>
<ol>
<li>计划阶段：设定各类参数<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="预期收益水平、风险承受能力、时间偏好、税率、流动性
">[1]</span></a></sup>。形成<strong>investment policy statement (IPS)</strong>，包含盈利目标和条件。</li>
<li>执行阶段：通过分析，决定资产组合方案。</li>
<li>反馈阶段：评估风险、收益，并作出调整。</li>
</ol>
</li>
</ul>
<h5 id="投资者、基金类型"><a href="#投资者、基金类型" class="headerlink" title="投资者、基金类型"></a>投资者、基金类型</h5><ul>
<li><p>固定缴存计划（defined contribution）、固定收益计划（defined benefit pension）</p>
<ul>
<li>固定缴存承诺过程，固定收益承诺回报。</li>
</ul>
</li>
<li><p>资产管理行业</p>
<ul>
<li>passive management：较低管理费用，较低风险，较低但相对稳定的收益</li>
<li>active management</li>
</ul>
</li>
<li><p>:question:几种类型的混合基金 </p>
<ul>
<li><p>共同基金</p>
<ul>
<li><p>可分为：开放式和封闭式</p>
<ul>
<li>open-end：可赎回、可交易</li>
</ul>
<blockquote>
<p>  投资者数量、基金池总额变动。</p>
</blockquote>
</li>
<li><p>closed-end：不可赎回、可交易</p>
<blockquote>
<p>  大多为主动管理</p>
<p>  直接与市场进行基金交易</p>
</blockquote>
</li>
</ul>
</li>
<li><p>其它几种类型</p>
<pre><code>-   货币基金：购买货币
</code></pre><ul>
<li>债券基金<ul>
<li>股票基金</li>
</ul>
</li>
</ul>
</li>
<li><p>exchange-traded fund（ETF）</p>
<ul>
<li><p>与closed-end基金比较：</p>
<p>相似：可交易、不可赎回</p>
<p>不同：大多为采用消极管理，紧跟指数收益。</p>
</li>
<li><p>与open-end基金比较：</p>
<p>不同：经纪人佣金（brokerage cost）较高；open-end能够以资产净值（NAV）进行买卖，而ETF买卖价格由</p>
</li>
</ul>
</li>
<li><p>私募、风险投资、套利基金（hedge funds）</p>
</li>
</ul>
</li>
</ul>
<h3 id="Portfolio-Risk-and-Return-Ⅰ"><a href="#Portfolio-Risk-and-Return-Ⅰ" class="headerlink" title="Portfolio Risk and Return Ⅰ"></a>Portfolio Risk and Return Ⅰ</h3><p><strong>「选取最优的投资组合：风险、收益以及投资者偏好」</strong></p>
<h5 id="收益计算"><a href="#收益计算" class="headerlink" title="收益计算"></a>收益计算</h5><ul>
<li><p>持有期收益(Holding period return)</p>
<blockquote>
<p>  $HPR = P_t-P_0+Div_t/P_0$</p>
</blockquote>
</li>
<li><p>平均收益</p>
<ul>
<li>算术平均：</li>
<li>几何平均：当各期收益率不同实，几何平均＜算术平均</li>
</ul>
</li>
<li><p>真实收益：<strong>近似</strong>等于名义收益—通货膨胀率</p>
</li>
<li><p>货币加权收益（money-weighted return）：考虑所有资金流入、流出的收益</p>
<ul>
<li><p>$PV<em>{inflow} = PV</em>{outflow}$</p>
</li>
<li><p>由于越往后账户中的货币越多，所以越往后期间内的权重可能变大。</p>
<blockquote>
<p>  如果追加投入后，收益下降，那么货币加权收益也将偏低。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>时间加权收益（time-weighted return）</p>
<ul>
<li>单独计算每期收益，最终求各期算术平均。</li>
</ul>
</li>
</ul>
<h5 id="协方差和相关性"><a href="#协方差和相关性" class="headerlink" title="协方差和相关性"></a>协方差和相关性</h5><ul>
<li><p>协方差：</p>
<ul>
<li>协方差的量级取决于：①单个对象收益标准差大小；②两个对象收益的同步变化程度</li>
<li>使用算术平均计算单个对象的平均收益</li>
</ul>
</li>
<li><p>相关性：对协方差剔除单个因子的影响（标准化后的协方差）</p>
<p>$ρ_{1,2}=COV/δ_1δ_2$</p>
<ul>
<li>相关性系数值域在【0，1】</li>
</ul>
</li>
</ul>
<h5 id="效率前沿-star"><a href="#效率前沿-star" class="headerlink" title="效率前沿:star:"></a>效率前沿:star:</h5><ul>
<li><p>组合方差、标准差的计算</p>
<p>$Var_{portfolio}=w_1^2σ_1^2+w_2^2σ_2^2+2w_1w_2Cov_12$</p>
<p>$σ<em>{portfolio}=Var</em>{portfolio}^{0.5}$</p>
<blockquote>
<p>  当两个对象呈正相关时，投资组合风险才等于各个资产的加权平均：</p>
<p>  $σ_{portfolio}=w_1σ_1+w_2σ_2$</p>
</blockquote>
<ul>
<li><p>相关系数越小时，组合方差越小。（多元化的优势）</p>
<p>-1 &gt; 0 &gt; 1</p>
</li>
</ul>
</li>
<li><p>效率前沿概念</p>
<ul>
<li><p>最小方差效率前沿：<strong>给定收益</strong>的所有可能的最小方差组合（minimum-variance portfolios）构成最小方差的效率前沿。</p>
</li>
<li><p>效率前沿：<strong>给定风险水平</strong>的收益最高的投资组合的集合</p>
<blockquote>
<p>  风险厌恶者只会选择位于效率前沿上的投资组合。</p>
</blockquote>
</li>
<li><p>全局最小方差组合：效率前沿上风险最低的投资组合</p>
</li>
</ul>
</li>
<li><p>资本分配曲线</p>
<ul>
<li>two-fund separation theorem：最优的投资者组合应<strong>优化的风险资产</strong>与<strong>无风险资产</strong>的组合</li>
</ul>
</li>
</ul>
<pre><code>-   资本分配线（capital allocation line，**CAL**）

    一条带有截距项的直线：

    $R=R_F+W_AR_A$

    &gt;   **资产分配线**与投资者**无差异曲线**的**切点**即为最优投资组合

-   与风险偏好相结合：

    一个风险厌恶程度更低的人，将获得更高收益，但更高风险的最优投资组合。
</code></pre><h3 id="Portfolio-Risk-and-Return-Ⅱ"><a href="#Portfolio-Risk-and-Return-Ⅱ" class="headerlink" title="Portfolio Risk and Return Ⅱ"></a>Portfolio Risk and Return Ⅱ</h3><p><strong>「风险与收益并不总是成正比：承担额外的非系统性风险并不会增加收益」</strong></p>
<h5 id="系统性风险"><a href="#系统性风险" class="headerlink" title="系统性风险"></a>系统性风险</h5><ul>
<li><p>将无风险资产加入投资组合：</p>
<p>$σ_{portfolio}=W_Aσ_A$</p>
<p>$E(R_p)=W_AE(R_A)+W_BE(R_B)$</p>
</li>
<li><p>能增加收益的风险</p>
<ol>
<li><p><strong>确定最优的无风险资产和有风险资产比例</strong></p>
<p>最优的CAL：与投资者无差别曲线相切的CAL</p>
</li>
<li><p><strong>确定CML和最优风险资产组合</strong></p>
<p>最优风险资产组合：最优CAL与效率前沿的切点</p>
<blockquote>
<p>  :star: 确定最优的市场回报点（$E(R_M)$），以此为依据判断具体资产是否值得买入：</p>
<ul>
<li><p>某项资产收益＞$E(R_M)$：买入</p>
</li>
<li><p>某项资产收益＜$E(R_M)$：卖出</p>
</li>
</ul>
</blockquote>
</li>
</ol>
<p>$E(R_p)=R_f+(E(R_M)-R_f)(σ_P/σ_M)$</p>
<ul>
<li>关于$σ_P$的函数</li>
<li><p>市场风险回报（market risk premium）：$E(R_M)-R_f$</p>
<blockquote>
<p>  :star: 为额外承受的每一单位市场风险（$σ_M$）获取市场风险回报</p>
<p>  承担额外的非系统性风险并不会增加收益</p>
</blockquote>
</li>
</ul>
</li>
<li><p>系统系风险：不能被多元化所抵消的风险（risk of well-diversified portfolio）</p>
<ul>
<li><p>系统性风险是相对的：由组合的具体情况决定。</p>
<blockquote>
<p>  一般弹性较大的资产组合具有较高的系统性风险。例如奢侈品具有较高的系统系风险。</p>
</blockquote>
</li>
<li><p>高风险股票不意味着高<strong>预期收益</strong>：只有背负系统性风险才能获取更高的<strong>预期收益</strong>（equilibrium return）。</p>
</li>
</ul>
</li>
</ul>
<h5 id="β"><a href="#β" class="headerlink" title="β"></a>β</h5><ul>
<li><p>计算单个资产的超额收益：超额收益是单个资产对多种因素敏感性的</p>
<ol>
<li><p>FAMA多因子模型：超额收益 = 敏感性1×因素1+敏感性2×因素2</p>
</li>
<li><p>单因子模型：资产的超额收益是β与市场超额收益的乘积</p>
<p>$E(R_i)-R_f=β_i×[E(R_m)-R_f]$</p>
</li>
<li><p>市场模型（market model）：</p>
<p>$R_i=α_i+β_iR_m+e_i$</p>
<ul>
<li><p>截距项$α_i=(1-β_i)$</p>
</li>
<li><p>预期收益$E(R_i)=α_i+β_iR_m$</p>
</li>
</ul>
<blockquote>
<p>  <strong>β表示一项资产对市场组合（market portfolio）的敏感性程度。</strong></p>
</blockquote>
</li>
</ol>
</li>
<li><p>BETA（β）的计算</p>
<p>:star: β是特殊标准化处理后的资产回报与市场回报的协方差: </p>
<ol>
<li>基本表达式：$β<em>i=COV</em>{im}/σ_M^2$</li>
<li>用相关系数代表协方差：$β<em>i=ρ</em>{im}(σ_i/σ_M)$</li>
</ol>
</li>
</ul>
<h5 id="CAPM模型"><a href="#CAPM模型" class="headerlink" title="CAPM模型"></a>CAPM模型</h5><ul>
<li><p>模型：描述预期资产回报与系统性风险的关系</p>
<p>$E(R<em>i)=R_f+β_i[E(R</em>{mkt}-R_f)]$</p>
<blockquote>
<p>  <strong>关于β的另一种理解：β是标准化后的系统性风险</strong></p>
<ul>
<li><p>$β=COV<em>{i,mkt}/σ</em>{mkt}^2$</p>
<p>:star:<strong>贝塔系数越高，投资该股的系统风险越高，投资者所要求的回报率也就越高</strong></p>
</li>
</ul>
</blockquote>
</li>
<li><p>内涵：资产的预期收益率等于无风险收益率加上β调整后的市场风险回报（market risk premium，$E(R_M)-R_f$）</p>
<ul>
<li>当β＞1时，资产收益大于市场收益</li>
<li>前提假设：①市场厌恶；②效用最大化；③无摩擦市场；④单期决定；⑤同质性假设；⑥所有资产可以随意拆分；⑦完全竞争市场</li>
</ul>
</li>
<li><p>CML与SML的区别:question:</p>
<ul>
<li><p>CML（capital market line）考虑了所有风险因素（total risk），所有CML上的点都是各自风险水平下最有效的（<strong>well-diversified</strong>）投资组合</p>
<blockquote>
<p>  <strong>没有完全多元化的</strong>的出现在与CML相切的效率前沿内。</p>
<p>  CML曲线上比切点高还是低来判断买入无风险资产来投资，或是投资无风险资产</p>
</blockquote>
</li>
<li><p>SML（security market line）考虑系统性风险（systematic risk），只要是定价合理的投资组合都在SML上</p>
<blockquote>
<p>  所有没在SML上的点都是在相同市场风险水平下，被错误定价的：</p>
<p>  SML下方：定价过高，卖出</p>
<p>  SML上方：定价过低，买入</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="几种重要的比率"><a href="#几种重要的比率" class="headerlink" title="几种重要的比率"></a>几种重要的比率</h5><ul>
<li><p>Sharp ratio：风险调整的收益</p>
<p>Sharp ratio = $E(R<em>{portfolio}-R_f)/σ</em>{portfolio}$</p>
<ul>
<li>是CAL的斜率</li>
<li>sharp ratio 越高，表现越好</li>
<li>基于总风险，而非系统风险：适用于各类投资类型分析。</li>
</ul>
</li>
<li><p>treynor ratio</p>
</li>
</ul>
<ul>
<li><p>$M^2$：承担每一份系统性风险的收益</p>
<p>$M^2 = R_p-R_f/β_p$</p>
</li>
<li><p>Jensen‘s alpha</p>
</li>
</ul>
<h3 id="Basic-of-Portfolio-Planning-and-Construction"><a href="#Basic-of-Portfolio-Planning-and-Construction" class="headerlink" title="Basic of Portfolio Planning and Construction"></a>Basic of Portfolio Planning and Construction</h3><h5 id="投资政策说明书（investment-policy-statement）"><a href="#投资政策说明书（investment-policy-statement）" class="headerlink" title="投资政策说明书（investment policy statement）"></a>投资政策说明书（investment policy statement）</h5><ul>
<li><p>组成要素：</p>
<ul>
<li><p>投资者环境（circumstance）：风险承受水平、预期收益</p>
<blockquote>
<p>  objectives and constraints</p>
</blockquote>
</li>
<li><p>投资策略（investment strategy）</p>
</li>
<li><p>对标（benchmark）：评估绩效</p>
</li>
</ul>
</li>
<li><p>投资者方面</p>
<ul>
<li>投资与风险目标（objectives）<ul>
<li>绝对风险目标与相对风险目标：对标benchmark设置收益不足预期的范围</li>
</ul>
</li>
<li>投资局限性（constraints）<ul>
<li>流动性要求</li>
<li>时间期限</li>
<li>税务</li>
<li>合规性</li>
</ul>
</li>
</ul>
</li>
<li><p>资产投资策略（strategic asset allocation）</p>
<ol>
<li><p>分清不同资产的收益与风险级别</p>
<blockquote>
<p>  包含：</p>
<p>  growth assets：指数、股票等</p>
<p>  downturn hedging assets：短期高质量信用贷款、固定收益（core）</p>
<p>  inflation hedging assets：房地产（core）、基础设施、抗通胀债券</p>
</blockquote>
</li>
<li><p>将投资策略与IPS相结合：选取最优投资组合</p>
<ul>
<li>主要根据objective（预期风险和收益目标）来选择</li>
<li>主动投资管理：可能带来更高风险与收益<ul>
<li>为获取短期收益进行技术性调整：tactical asset allocation</li>
<li>risk budgeting：①设定总风险水平；②设定技术性操作的风险额度。<ul>
<li>多个不同主动投资管理的风险可以对冲</li>
<li>多个主动投资管理可能带来更高的税务问题</li>
</ul>
</li>
<li>核卫星策略（core-statellite approach）：将核心资产（大部分资产）投资于被动管理的指数基金</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="Introduction-to-Risk-Management"><a href="#Introduction-to-Risk-Management" class="headerlink" title="Introduction to Risk Management"></a>Introduction to Risk Management</h3><h5 id="关于风险管理"><a href="#关于风险管理" class="headerlink" title="关于风险管理"></a>关于风险管理</h5><ul>
<li><p>目的：风险管理的目的并非要最小化风险，而是<strong>在一定的风险水平下获取最大的收益</strong>。</p>
</li>
<li><p>风险管控（risk governance）：明确各项风险管理政策。</p>
</li>
<li><p>风险承受水平（risk tolerance）：关于确定总风险水平，由企业的能力及环境决定。</p>
</li>
<li><p>风险预算（risk budgeting）：关于向各资产分配风险配额。</p>
<blockquote>
<p>  重点在于结合具体股票的风险特点和总的风险水平，来<strong>选择</strong>资产组合，从而通过风险对冲等方式找到最佳组合，</p>
</blockquote>
</li>
</ul>
<h5 id="关于风险"><a href="#关于风险" class="headerlink" title="关于风险"></a>关于风险</h5><ul>
<li>财务风险：来源于金融市场的风险<ul>
<li>信用风险：企业无法按时履约</li>
<li>流动性风险：需要以低于真实价格来出售资产</li>
<li>市场风险：利率及资本定价的调整</li>
</ul>
</li>
<li><p>非财务风险</p>
<ul>
<li>经营风险</li>
<li>偿债风险</li>
<li>政策风险</li>
<li>合规性风险</li>
<li>会计风险</li>
<li>模型风险：分析模型错误</li>
<li>尾部风险：低估小概率时间的爆发</li>
</ul>
</li>
<li><p>风险度量方式</p>
<ul>
<li><p>标准差：度量资产定价及收益（price &amp; interest rates）</p>
<ul>
<li>适用于独立的（stand-alone）资产</li>
</ul>
</li>
<li><p>β：度量收益对市场风险（不稳定性/变化）的敏感性</p>
<ul>
<li>β的本质是资产收益与市场收益的协方差，现实中可以用个股对指数间的关系来计算。</li>
</ul>
</li>
<li><p>久期：度量债券价格对利率变化的敏感性</p>
<ul>
<li><p>度量债券的利率风险</p>
<blockquote>
<p>  久期越短，债券价格的波动越小，风险越小；</p>
<p>  久期越长，债券价格的波动越大，风险越大。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Var：风险资产</p>
<ul>
<li>CVar：在最小损失已经确实后，预期的损失</li>
<li>压力测试：设定关键变量，评估后果</li>
<li>情景分析：改变多个输入变量，评估后果</li>
</ul>
</li>
</ul>
</li>
<li><p>风险应对策略</p>
<ul>
<li>avoid：不参与</li>
<li>prevent：补充监管，弥补数据漏洞</li>
<li>management：多元化<ul>
<li>risk transfer：保险、担保（surety bond）</li>
<li>risk shifting：改变风险的结果（风险发生了，但结果不一样）。<strong>一般选择衍生品。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="技术性分析"><a href="#技术性分析" class="headerlink" title="技术性分析"></a>技术性分析</h3><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><ul>
<li>概念：结合市场情绪对买卖双方的行为进行预测<ul>
<li>考虑市场理性和非理性因素，<strong>认为投资者的行为模式是可预测的</strong>（不基于市场有效性假说）</li>
<li>与基本面分析的区别<ul>
<li>基本面分析重在发现资产内在价值，技术性分析在于分析交易发生逻辑</li>
<li>基本面分析依据公司财报等多方面信息，技术性分析只考虑股价及交易量。</li>
<li>技术性分析不关注买卖双方的原因，仅关注已发生的交易。</li>
</ul>
</li>
<li>技术分析的优缺点<ul>
<li>优点：①基于客观且可观测数据；②可用于对未来不产生现金流的资产的定价，如原油。</li>
<li>缺点：不能反映资产真正的供需关系</li>
</ul>
</li>
</ul>
</li>
<li>常见类型<ul>
<li>反转形态（reversal patterns）</li>
</ul>
</li>
</ul>
<h3 id="Fintech-in-Investment-Management"><a href="#Fintech-in-Investment-Management" class="headerlink" title="Fintech in Investment Management"></a>Fintech in Investment Management</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>预期收益水平、风险承受能力、时间偏好、税率、流动性
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>CFA</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>[CFA-1] 权益投资</title>
    <url>/2020/02/29/CFA/Equity_Investment/</url>
    <content><![CDATA[<h2 id="Equity-Investment"><a href="#Equity-Investment" class="headerlink" title="Equity Investment"></a>Equity Investment</h2><h3 id="Market-Organization-and-Structure"><a href="#Market-Organization-and-Structure" class="headerlink" title="Market Organization and Structure"></a>Market Organization and Structure</h3><h5 id="金融市场基本概念"><a href="#金融市场基本概念" class="headerlink" title="金融市场基本概念"></a>金融市场基本概念</h5><ul>
<li>金融市场的作用<ul>
<li>通过利率决定资金供给</li>
<li>有效配置资源</li>
</ul>
</li>
<li>金融资产<ul>
<li>证券</li>
<li>衍生品</li>
<li>外汇</li>
</ul>
</li>
<li><p>市场</p>
<ul>
<li>现货市场（spot market）- 期货市场</li>
<li>一级市场：IPO等新发证券 - 二级市场：股票市场</li>
<li>货币市场：短期债券交易 - 资本市场：长期债券交易</li>
<li>传统市场：债权与股权交易 - 替代市场：对冲基金、大众商品、房地产交易</li>
</ul>
</li>
<li><p>证券（securities）</p>
<ul>
<li><p>固定收益：债券（debt security）</p>
</li>
<li><p>浮动收益：股票（equity security）</p>
<ul>
<li>普通股、优先股、认股权证（warrants）</li>
</ul>
</li>
<li><p>多个投资者</p>
<ul>
<li><p>共同基金</p>
<blockquote>
<p>open-end：直接向基金购买，<strong>基金净值 = 交易价格（即赎回）</strong></p>
<p>closed-end：在二级市场购买，<strong>实际交易价格受到二级市场供需关系影响</strong></p>
</blockquote>
</li>
<li><p>ETF &amp; ETN：类似于closed-end 基金，但 :question:</p>
</li>
<li><p>资产抵押债券（asset-backed security）：通过资产的收益来获得收益</p>
</li>
<li>对冲基金（hedge fund）：</li>
<li><p>契约（contracts）：约定在未来交易的契约</p>
<ul>
<li><p>远期契约（forward contracts）：约定在未来以特定价格进行交易</p>
</li>
<li><p>期货合约（future contracts）：类似于远期契约，但对单位进行标准化，在二级市场进行交易，因此拥有较高流动性。</p>
<blockquote>
<p>标准化的远期合约，可以不涉及实物交易。</p>
</blockquote>
</li>
<li><p>掉期合约（swap contracts）：约定在未来交换两项资产的收益。。。</p>
</li>
<li><p>期权合约（option contracts）：</p>
<ul>
<li>call：买的权力</li>
<li>put：卖的权利</li>
</ul>
</li>
<li><p>保险合约（insurance contracts）</p>
</li>
<li><p>信用违约交换（credit default swap）：对冲债券违约风险-</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>不动产</p>
<ul>
<li>优点：多元化收入；税收优惠</li>
<li>缺点：低流动性；专业性要求</li>
<li>间接购买不动产：房地产投资信托（REIT）</li>
</ul>
</li>
<li><p>金融中介</p>
<ul>
<li>经纪人<ul>
<li>block broker ：大单经纪人</li>
</ul>
</li>
<li>做市商：dealer</li>
<li>投行：帮助公司发行新股票、提供咨询服务</li>
<li>交易所：提供交易场所</li>
</ul>
</li>
</ul>
<h5 id="头寸和杠杆率"><a href="#头寸和杠杆率" class="headerlink" title="头寸和杠杆率"></a>头寸和杠杆率</h5><ul>
<li><p>多头和空头</p>
<ul>
<li>区别<ul>
<li>多头：价格上涨时获利</li>
<li>空头：价格下跌时获利</li>
</ul>
</li>
<li>资产持有者可以利用卖空头寸来在期货交易中对冲风险。<ul>
<li>卖空交易的细节<ul>
<li>分红怎么处理？——payments in lieu</li>
<li>卖空后交给经纪人托管的资金利息怎么处理？——short rebate rate</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>杠杆头寸：以借入资金的方式来购买资产</p>
<ul>
<li><p>关键要素</p>
<ul>
<li><p>初始购买金率（initial margin requirement）</p>
<blockquote>
<p>即杠杆率</p>
</blockquote>
</li>
<li><p>接入资金利息（call money rate）</p>
</li>
<li><p>佣金（commission）</p>
</li>
<li><p>应付保证金（maintenance margin requirement）</p>
</li>
</ul>
</li>
<li><p>收益计算</p>
</li>
<li><p>margin call 计算：<strong>保证借款部分不被资产价格降低而缩水</strong></p>
<ul>
<li>$P_1=P_0（1-I_i/1-I_m）$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="交易指令"><a href="#交易指令" class="headerlink" title="交易指令"></a>交易指令</h5><ul>
<li><p>买卖价格（站在做市商的视角）</p>
<ul>
<li><p>买价（bid price）：做市商购买资产的价格</p>
</li>
<li><p>卖价（ask/offer price）：做市商卖掉资产的价格</p>
</li>
<li><p>买卖价差（bid-ask spread）</p>
<blockquote>
<p>做市商的收益</p>
</blockquote>
</li>
</ul>
</li>
<li><p>交易指令</p>
<ul>
<li><p>执行指令（execution instruction）：<strong>如何交易？</strong></p>
<ul>
<li><p>市场指令（market order）：<strong>立即</strong>以市场当时的<strong>最优价格</strong>买入</p>
<blockquote>
<p>优点：投资者有市场尚未消化的信息时，希望立刻买入。流动性高</p>
<p>缺点：买卖价格未知，可能超预期</p>
</blockquote>
</li>
<li><p>限价指令（limit order）：根据指定价格买卖</p>
<blockquote>
<p>优点：明确收益</p>
<p>缺点：可能不能完成交易</p>
</blockquote>
</li>
<li><p>考虑成交量的指令</p>
</li>
<li>考虑交易公开性的指令</li>
</ul>
</li>
<li><p>有效指令（validity instruction）：<strong>何时交易？</strong></p>
<ul>
<li>当日有效</li>
<li>立即成交否则不成交委托：要么<strong>立即</strong>全部成交，要么<strong>不成交</strong></li>
<li>止损买单</li>
</ul>
</li>
<li><p>清算指令（clearing instruction）：<strong>如何结算？</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="市场类型"><a href="#市场类型" class="headerlink" title="市场类型"></a>市场类型</h5><h3 id="Security-market-indexs"><a href="#Security-market-indexs" class="headerlink" title="Security market indexs"></a>Security market indexs</h3><h5 id="证券指数的回报"><a href="#证券指数的回报" class="headerlink" title="证券指数的回报"></a>证券指数的回报</h5><ul>
<li>价格指数：反映组成的成分股的价格变化</li>
<li>总收益指数：组合期间内的收益，以及收益的收益</li>
</ul>
<h5 id="证券指数收益的赋权方式"><a href="#证券指数收益的赋权方式" class="headerlink" title="证券指数收益的赋权方式"></a>证券指数收益的赋权方式</h5><ul>
<li><p>price-weight：根据价格对收益进行加权</p>
<ul>
<li><p>收益计算：$p_1+p_2+p_3/n$</p>
<blockquote>
<p>  假设购买相同股份，每个股票的价格即为<strong>自己收益</strong>的权重。</p>
</blockquote>
</li>
<li><p>何时修正赋权（rebalance）</p>
</li>
<li><p>特点：</p>
<ul>
<li>价格高股票的变动影响更大。</li>
<li>当某只股票发生拆股时，由于股东的财富没有改变，<strong>因此，指数（price-weighted）不应改变，应对调整分母股票的数量</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>equal-weight：不对收益进行加权（un-weighted）</p>
<ul>
<li><p>收益计算：</p>
<ul>
<li>算术平均法：$R_A+R_B+R_C/n$</li>
<li><p>指数平均法：$(R_A+R_B+R_C)^{(1/n)}$</p>
<blockquote>
<p>  假设购买相同股份，每个股票的权重相同。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>每只股票的收益率都对最终的收益有相同的影响。</li>
<li><strong>小盘股票的波动可能更加剧烈，因此对最终的指数收益可能影响更大。</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>capitalization-weight：根据市值对收益加权</p>
<ul>
<li><p>如何计算收益：市值之比</p>
</li>
<li><p>特点</p>
<ul>
<li><p>不用对股票分拆及股利发放进行调整</p>
</li>
<li><p>解决了高价格股票和小盘口股票带来的偏差，但也带来了新的偏差：</p>
<ul>
<li><p>但未流通的股票也会带来偏差</p>
<blockquote>
<p>  float-adjusted ：只对实际流通的股票进行计算。</p>
</blockquote>
</li>
<li><p>股票价值被不均等的高估</p>
<blockquote>
<p>  基本面加权：利用公司财务指标来加权</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="对指数进行调整"><a href="#对指数进行调整" class="headerlink" title="对指数进行调整"></a>对指数进行调整</h5><ul>
<li>rebalance：股票<strong>价格的变动</strong>导致其在指数中的权重偏离既定目标值。<ul>
<li>调整是通过买卖股票实现的。<strong>买卖是有成本的，</strong>所以不能频繁调整。</li>
<li>什么类型的指数需要rebalance：<ul>
<li>对于<strong>价格指数</strong>和<strong>市值指数</strong>，价格变动自动带来权重调整。（因为目标值就包含了价格因素！）</li>
<li>对位<strong>等权重指数</strong>，如果价格没有等比例变化，那么权重就会改变</li>
</ul>
</li>
</ul>
</li>
<li>reconstitution：如果股票不具有代表性了，就应当删除。</li>
</ul>
<h5 id="主流指数"><a href="#主流指数" class="headerlink" title="主流指数"></a>主流指数</h5><ul>
<li>股票指数<ul>
<li>大盘指数：衡量大盘整体表现的方法，通常包含市场90%以上的总市值</li>
<li>多市场指数：专注细分市场<ul>
<li>以基本面为权重的多市场指数：如以国家GDP进行加权</li>
</ul>
</li>
<li>行业指数</li>
<li>风格指数：划分不同的投资风格来区分指数市场</li>
</ul>
</li>
<li>固定收益指数<ul>
<li>相较于股票指数：<ul>
<li>范围更大：对于债券市场，政府也可放债。</li>
<li>交易不活跃：价格信息不准确</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="其它投资指数"><a href="#其它投资指数" class="headerlink" title="其它投资指数"></a>其它投资指数</h5><ul>
<li>房地产</li>
<li>大宗商品：以期货数据为依据计算</li>
<li>对冲基金<ul>
<li>由于样本选择性偏误，<strong>对冲基金指数并不能真实地反映对冲基金的业绩</strong></li>
</ul>
</li>
</ul>
<h3 id="Market-Efficiency"><a href="#Market-Efficiency" class="headerlink" title="Market Efficiency"></a>Market Efficiency</h3><p><strong>「有效市场中，价格反映了所有过去、现在、公开、非公开的信息，并且会迅速对新的信息作出反映」</strong></p>
<blockquote>
<p>  :star:理解三种形式的市场有效性</p>
</blockquote>
<h5 id="认识有效市场"><a href="#认识有效市场" class="headerlink" title="认识有效市场"></a>认识有效市场</h5><ul>
<li>通过交易行为来反映市场有效程度</li>
<li>有效市场中，市场价值=内在价值</li>
<li>高度有效市场的特征<ul>
<li>参与者多</li>
<li>信息易于获取</li>
<li>交易限制少：<strong>是否允许套利和做空</strong></li>
<li>交易成本、信息获取成本低</li>
</ul>
</li>
</ul>
<h5 id="三种类型的有效市场"><a href="#三种类型的有效市场" class="headerlink" title="三种类型的有效市场"></a>三种类型的有效市场</h5><ul>
<li>强势有效：价格反映所有信息<ul>
<li><strong>所有分析都失效</strong>，没有办法获取超额收益</li>
</ul>
</li>
<li>半强势有效：价格反映所有公开信息（市场或非市场）<ul>
<li><strong>技术分析</strong>失效，<strong>基本面分析</strong>部分失效</li>
</ul>
</li>
<li>弱势有效：价格反映市场信息<ul>
<li>投资者不可能通过分析以往价格获得超额利润：<strong>技术分析失效</strong></li>
</ul>
</li>
</ul>
<h5 id="市场反常（abnormal）"><a href="#市场反常（abnormal）" class="headerlink" title="市场反常（abnormal）"></a>市场反常（abnormal）</h5><ul>
<li>根据市场有效性假说，任何一种股票或其组合的<strong>平均超额收益</strong>都该为零。如果出现超额收益，并不能否认市场有效性，因为有很多人为因素。</li>
</ul>
<h5 id="行为金融学"><a href="#行为金融学" class="headerlink" title="行为金融学"></a>行为金融学</h5><ul>
<li>已确认的行为偏差<ul>
<li>损失厌恶：风险与收益偏好的非对称：损失的痛苦大于收益的喜悦</li>
<li>过度自信：高估自己的分析能力</li>
</ul>
</li>
</ul>
<h3 id="Overview-of-Equity-Securities"><a href="#Overview-of-Equity-Securities" class="headerlink" title="Overview of Equity Securities"></a>Overview of Equity Securities</h3><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><ul>
<li><p>权益投资类别</p>
<ul>
<li><p>普通股（common shares）</p>
<ul>
<li>在债权和优先股后对公司剩余资产具有申索权</li>
<li>投票权：理事会；公司重大事项</li>
</ul>
<blockquote>
<p>按照投票权分为A类、B类普通股：</p>
<ul>
<li>投票权不同</li>
<li>清算时申索权不同</li>
</ul>
</blockquote>
</li>
<li><p>优先股（preferrence shares）</p>
<ul>
<li>一般具有周期性的固定收益</li>
<li><p>一般不具有投票权</p>
</li>
<li><p>可以按预定价格进行回购（callable）会回售（putable）</p>
</li>
</ul>
<blockquote>
<p>累积优先股（cumulative preference shares）：</p>
<ul>
<li>固定分红，如果没有，后期将在普通股分红前进行补偿</li>
</ul>
<p>非累积优先股（non cumulative preference shares）</p>
<ul>
<li>固定丰厚，如果错过，后期不补。但如果有，将在普通股分红前获得分红</li>
</ul>
<hr>
<p>参与管理优先股（participating preference share）</p>
<ul>
<li>公司收益时，获取超过预定分红比率的分红</li>
<li>公司清算时，获取更高份额的回报</li>
</ul>
<p>不参与管理优先股（non-participating share）</p>
<ul>
<li>对公司利润没有申索权</li>
</ul>
</blockquote>
</li>
<li><p>可兑换优先股（convertible preferred shares）：可转换成普通股</p>
<ul>
<li>一般比普通股具有更高分红，且更小风险。</li>
</ul>
<blockquote>
<p>如果公司盈利：普通股价格上升，转换成普通股以获得收益</p>
<p>如果公司不盈利：保持较高分红、低风险</p>
</blockquote>
</li>
</ul>
</li>
<li><p>私募股权与公募股权的区别</p>
<ul>
<li>私募股权主要面向机构投资者</li>
<li>与公募股权的区别：<ul>
<li>流动性更差：不存在公开交易市场</li>
<li>协定议价：不存在公开定价</li>
<li>更少的公司财务信息披露<ul>
<li>公司治理、披露成本、</li>
</ul>
</li>
<li>更能专注长期目标</li>
<li>可能具有高额收益</li>
</ul>
</li>
</ul>
</li>
<li>风险投资</li>
<li><p>杠杆收购（leveraged buyout, LBO）：利用债务融资来进行收购</p>
<ul>
<li>收购方为管理层：MBO</li>
</ul>
</li>
<li>上市后私募增发（PIPE）：向投资者以市场价的折后价出售私人股权。</li>
</ul>
<h5 id="国外权益与权益风险"><a href="#国外权益与权益风险" class="headerlink" title="国外权益与权益风险"></a>国外权益与权益风险</h5><ul>
<li><p>投资国外权益的方式</p>
<ul>
<li><p>直接投资：直接在当地公开市场购买权益</p>
<ul>
<li>外币结算</li>
<li>环境法规风险</li>
</ul>
</li>
<li><p>间接投资：</p>
<blockquote>
<p>存托凭证（deposit receipts）：在某公司非发行地的股权。一般由投资者所在地的银行代理</p>
<ul>
<li>有人购买：sponsored DR</li>
<li>无人购买：unsponsored DR，由银行获取投票权</li>
</ul>
</blockquote>
<ul>
<li><p>全球存托凭证（GDRs）：既不在美国、也不再股票发行地</p>
<blockquote>
<p>一般在伦敦或者卢森堡：使用美元交易、没有环境法规限制。</p>
</blockquote>
</li>
<li><p>美国存托凭证（ADRs）：美国交易、美元计价，除私人交易其他均需要符合美国制度要求</p>
</li>
<li><p>全球注册股权（GRSs）：全球交易</p>
</li>
<li><p>一揽子存托凭证（BLDR）：一揽子DR一起交易。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="权益收益"><a href="#权益收益" class="headerlink" title="权益收益"></a>权益收益</h5><ul>
<li><p>组成部分：价格变动+分红+汇率</p>
</li>
<li><p>风险比较</p>
<ul>
<li>优先股 &lt; 普通股</li>
<li>累计优先股 &lt; 非累积优先股</li>
<li>可回售 &lt; 可赎回</li>
</ul>
</li>
<li><p>权益计价：权益市值（market value of equity）≠ 权益账面价值（book value of equity）</p>
<ul>
<li>ROE：<strong>扣除优先股分红后</strong>的普通股收益/期间内平均账面价值</li>
<li>price-to-book ratio：权益市值/权益账面价值<ul>
<li>反应股票的相对价值：PB越低，公司股价可能被低估。</li>
</ul>
</li>
</ul>
</li>
<li>权益成本：包含分红的所有在市场流通股权的收益</li>
<li>投资者预期收益：公司的内在价值等于未来现金流的折现值<ul>
<li>预期收益越高（折现率越高），折现价值越低。反之，股价降低了，对未来的预期收益率提高。</li>
</ul>
</li>
</ul>
<h3 id="Introduction-to-Industry-and-Company-Analysis"><a href="#Introduction-to-Industry-and-Company-Analysis" class="headerlink" title="Introduction to Industry and Company Analysis"></a>Introduction to Industry and Company Analysis</h3><p>「明确行业、理解企业周期、行业战略分析、议价能力、公司竞争战略」</p>
<h5 id="行业分析"><a href="#行业分析" class="headerlink" title="行业分析"></a>行业分析</h5><p>「所在不同行业的企业不使用同一基本面分析」</p>
<ul>
<li>分类机构<ul>
<li>政府制定：</li>
<li>商业公司制定：主要依据企业产品与服务</li>
</ul>
</li>
<li>行业分析的要素<ul>
<li>理解宏观经济变量与行业趋势的关系</li>
<li>基于不同情形对行业的重要参数进行预测</li>
<li>评估不同行业的相对价值</li>
<li>识别行业内不同类型的企业，并对其未来进行预测</li>
<li>判断行业所处的周期</li>
<li>识别行业的经验曲线（experience curve）</li>
<li>理解影响行业的重要因素：宏观经济、人口、技术、社会</li>
<li>理解行业竞争的决定性因素</li>
</ul>
</li>
<li>行业分析工具：波特五力模型<ul>
<li>现存竞争对手</li>
<li>潜在进入者</li>
<li>替代者</li>
<li>下游市场购买力</li>
<li>上游市场供给能力</li>
</ul>
</li>
</ul>
<h5 id="企业分析：议价权（竞争力）"><a href="#企业分析：议价权（竞争力）" class="headerlink" title="企业分析：议价权（竞争力）"></a>企业分析：议价权（竞争力）</h5><ul>
<li>不同类型市场下的企业议价权<ul>
<li>进入、退出门槛：<ul>
<li>进入门槛越高，竞争越小，议价权越大（<strong>不绝对</strong>，同质化商品）</li>
<li>退出门槛越高，竞争越大，议价权越小</li>
</ul>
</li>
<li>市场集中度：越集中，竞争越小</li>
<li>行业产能：是否供过于求？</li>
<li>市场份额稳定性</li>
</ul>
</li>
<li>行业生命周期<ul>
<li>萌芽期（embryonic）：竞争小、成长慢、价格高、风险高</li>
<li>成长期（growth）：竞争较小、成长快、价格开始下降</li>
<li>shakeout：竞争大、产能过剩、利润下降、成长减速</li>
<li>成熟期：进入寡头竞争、成长慢、进入门槛高</li>
<li>衰退期：负增长、价格下降、企业退出</li>
</ul>
</li>
<li>公司竞争战略<ul>
<li>低成本：低价以获取市场</li>
<li>差异化：公司差异化产品提供的增量不能高于成本的增量</li>
</ul>
</li>
</ul>
<h3 id="Equity-valuation：concepts-and-basic-tools"><a href="#Equity-valuation：concepts-and-basic-tools" class="headerlink" title="Equity valuation：concepts and basic tools"></a>Equity valuation：concepts and basic tools</h3><h5 id="权益估值模型"><a href="#权益估值模型" class="headerlink" title="权益估值模型"></a>权益估值模型</h5><ul>
<li>折扣现金流模型：该投资未来所有现金流的贴现<ul>
<li>股利折现模型：<strong>未来派发给股东的股利</strong>的折现</li>
<li>自由现金流模型：企业扣除<strong>资本开支</strong>和<strong>周转开支</strong>后可供股东分配的现金流</li>
</ul>
</li>
<li>乘数模型<ul>
<li>基于股票价格的乘数：股价与公司基本面数据的比率（P/B）</li>
<li>基于企业价值的乘数：企业价值与企业收益的比率（企业价值与EBITDA的比率）</li>
</ul>
</li>
<li>资产模型<ul>
<li>普通股的内在价值=总资产-（负债+优先股）</li>
</ul>
</li>
</ul>
<h5 id="股利"><a href="#股利" class="headerlink" title="股利"></a>股利</h5><ul>
<li><p>现金股利</p>
</li>
<li><p>股票股利</p>
<blockquote>
<p>  与股票分拆的异同：</p>
<ul>
<li>相同：每股市价降低，股东总权益不变</li>
<li>不同：每股账面价值不同，股东权益结构改变，股东财富增加。</li>
</ul>
</blockquote>
</li>
</ul>
<h5 id="折扣现金流模型"><a href="#折扣现金流模型" class="headerlink" title="折扣现金流模型"></a>折扣现金流模型</h5><ul>
<li>具体操作<ul>
<li>固定股利贴现</li>
<li>固定增速股利贴现</li>
<li>含有高增速阶段的固定增速股利贴现</li>
</ul>
</li>
<li>优缺点<ul>
<li>优点：具有理论和现实意义</li>
<li>缺点：结果对输入的估计值敏感</li>
</ul>
</li>
</ul>
<h5 id="乘数模型"><a href="#乘数模型" class="headerlink" title="乘数模型"></a>乘数模型</h5><ul>
<li><p>具体操作</p>
<ul>
<li><p>基于公司的乘数模型：</p>
</li>
<li><p>基于基本面的乘数模型：$\frac{P_0}{E_1}=\frac{D_1/E_1}{k-g}$</p>
<blockquote>
<ul>
<li>调整的PE：针对未来收益（现金流）的PE，不是基于历史数据计算的</li>
<li>为判断公司的乘数提供标准</li>
</ul>
</blockquote>
</li>
<li><p>基于企业价值（EV）的乘数模型：$EV/EBITDA$</p>
</li>
</ul>
</li>
<li><p>优缺点</p>
<ul>
<li>优点：①指数易于获取</li>
<li>缺点：①无法对周期性企业比较；②无法对不同规模等的企业比较；③不能有负值（除基于企业价值的乘数模型外）</li>
</ul>
</li>
</ul>
<h5 id="资产模型"><a href="#资产模型" class="headerlink" title="资产模型"></a>资产模型</h5><ul>
<li>具体操作<ul>
<li>利用资产负债表计算：企业资产总市值 - 企业负债总市值</li>
</ul>
</li>
<li>优缺点：<ul>
<li>优点：①提供企业的最低估值；</li>
<li>缺点：①缺乏对无形资产的衡量；②不适用于超级通胀的环境</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>CFA</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
